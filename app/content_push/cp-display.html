<!--
scrolling image search results component; responsible for tracking
the state of any ongoing search, displaying waiting spinners, and
pushing new tiles into the wrapped layout
-->
<link rel="import" href="../bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="../bower_components/paper-slider/paper-slider.html">
<link rel="import" href="./cp-scroll.html">
<link rel="import" href="./cp-layout.html">
<link rel="import" href="./cp-tile-file.html">
<link rel="import" href="./cp-tile-image.html">

<polymer-element name="cp-display">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      .fill {
        width: 100%;
        height: 100%;
      }

      .message-area {
        text-align: center;
        width: 60%;
        margin-left: 20%;
        box-sizing: border-box;
      }

      #preresults {
        padding-top: 3em;
      }

      #scroller {
        width: 100%;
        height: 100%;
        margin-bottom: 48px; /* for the slider */
      }

      #results {
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        height: 100%;
      }

      #waiting {
        display: flex;
        background-color: white;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1000;
        -webkit-animation-duration: 0.25s;
        animation-duration: 0.25s;
        -webkit-animation-timing-function: ease-out;
        animation-timing-function: ease-out;
      }

      #waiting.fadein {
        -webkit-animation-name: fadein;
        animation-name: fadein;
      }

      #waiting.fadeout {
        -webkit-animation-name: fadeout;
        animation-name: fadeout;
      }

      @-webkit-keyframes fadein {
        from { opacity: 0; }
        to   { opacity: 1; }
      }

      @-webkit-keyframes fadeout {
        from { opacity: 1; }
        to   { opacity: 0; }
      }

      [data-show="false"] {
        display: none !important;
      }

      paper-slider {
        position: absolute;
        bottom: 0;
        width: 100%;
        max-height: 48px;
        min-height: 48px;
        padding: 8px 0;
        background-color: white;
        box-sizing: border-box;
      }

      /* slider colors (oh dear...) */
      /* bar */
      paper-slider::shadow #sliderBar::shadow #activeProgress {
        background-color: #0f9d58;
      }

      /* knob */
      paper-slider::shadow #sliderKnobInner {
        background-color: #0f9d58;
      }
    </style>

    <!--
    states for this component:

    - preresults - no search initiated, displays welcome message
    - results - slider is shown with results (or empty results)
    -->

    <!-- never searched -->
    <div id="preresults" class="message-area"
         data-show="{{state === 'preresults'}}">
      <p>Your related content should arrive shortly.</p>
      <paper-spinner active></paper-spinner>
    </div>

    <!-- after results are found -->
    <div id="results" class="fill">
      <!-- full page loader; can overlay image display -->
      <div id="waiting" class="fill" data-show="{{waiting && state !== 'preresults'}}">
        <paper-spinner active></paper-spinner>
      </div>

      <!-- image display -->
      <cp-scroll id="scroller"
                 on-scrollend="{{onScrollerScrollend}}"
                 data-show="{{state === 'results'}}">
        <!-- results -->
        <cp-layout id="layout"
                   data-show="{{state === 'results'}}"
                   on-layout="{{onLayoutLayout}}">
        </cp-layout>
      </cp-scroll>

      <!-- "widen the search" slider -->
      <paper-slider id="slider" min="0" max="100" value="50"
                    on-change="{{sliderChanged}}" data-show="{{state !== 'preresults'}}">
      </paper-slider>
    </div>
  </template>

  <script src="../bower_components/lodash/dist/lodash.js"></script>

  <script>
    (function () {
      /* maximum time in ms to wait for a tile to load for a query */
      var TIMEOUT = 5000;

      Polymer({
        /* state of the results; 'preresults' or 'results' */
        state: 'preresults',

        /* whether we are waiting for a tile to load or not */
        waiting: false,

        ready: function () {
          /* timeout to clear the waiting element if no tile is loaded
             successfully */
          this.waitTimeout = null;
        },

        /**
         * Set criteria for filtering the content of the display.
         *
         * @param {object} criteria Criteria for the filter
         * @param {object} criteria.activeKeywords an array of active keywords
         *
         * Right now, the first keyword in the keywordInfo.keywords
         * array is used as the filter. Any tile whose keyword.text
         * property matches this active keyword and has a type
         * matching one of the members of "types" will be displayed.
         */
        setFilter: function (criteria) {
          var self = this;

          if (!criteria.activeKeywords) {
            return;
          }

          var keywords = criteria.activeKeywords.map(function (keyword) {
            return keyword.text;
          });

          criteria.types = criteria.types || [];

          /* set the filter on the layout to the current keyphrase */
          this.$.layout.setFilter(function (tile) {
            var keywordMatches = false;
            for (var i = 0; i < tile.keywords.length; i++) {
              var index = keywords.indexOf(tile.keywords[i].text);
              if (index !== -1) {
                keywordMatches = true;
                tile.keywords[i] = criteria.activeKeywords[index];
              }
            }

            if (!keywordMatches) {
              return false;
            }

            var typeMatches;
            /* no types criteria, so always matches */
            if (criteria.types.length === 0) {
              typeMatches = true;
            } else {
              typeMatches = _.contains(criteria.types, tile.type);
            }

            return keywordMatches && typeMatches;
          });
        },

        /**
         * Add results to the layout.
         *
         * Each result in the results array should look like:
         * {
         *   src: <url of image>,
         *   keyword: {
         *     text: <keyphrase text>,
         *     groupId: <keyphrase groupId>
         *   },
         *   meta: { ... metadata ... },
         *   caption: <image caption>,
         *   source: <url of image source>
         * }
         */
        receiveResults: function (results) {
          for (var i = 0; i < results.length; i++) {
            if (results[i].type === 'image') {
              this.appendImage(results[i]);
            } else if (results[i].type === 'file') {
              this.appendFile(results[i]);
            }
          }
        },

        onScrollerScrollend: function () {
          this.fire('moreresults');
        },

        /**
         * Add a cp-tile* element to the layout, attaching handlers
         * at the same time and associating the keyword with it.
         *
         * @param {DOMElement} tile cp-tile* element to add to the
         * layout inside this display.
         * @param {string} keyword Keyword to associate with this tile.
         */
        addTile: function (tile, keyword) {
          var self = this;

          if (tile.keywords.indexOf(keyword) === -1)
            tile.keywords[tile.keywords.length] = keyword;

          tile.addEventListener('mouseover', function () {
            self.fire('mouse-over', tile.keywords);
          });

          tile.addEventListener('mouseout', function () {
            self.fire('mouse-out', tile.keywords);
          });

          tile.addEventListener('click', function () {
            self.fire('mouse-down', tile);
          });

          this.$.layout.addTile(tile);
        },

        /* when a layout happens, check whether any tiles are visible
           and stop waiting indicator if they are */
        onLayoutLayout: function () {
          if (this.$.layout.getCountVisibleTiles() > 0) {
            this.state = 'results';
            this.stopWaiting();
          }
        },

        /**
        * Convenience method to append an image tile to the
        * gallery; creates a cp-tile-image element for the image
        * object added.
        *
        * @param Object image Representation of image to add; has the
        * format:
        * {
        *   thumbnailSrc: "<url of image thumbnail>",
        *   width: <width of full-size image>,
        *   height: <height of full-size image>,
        *   keyword: {
        *       text: "<keyphrase text>",
        *       groupId: "<keyphrase group ID>"
        *   },
        *   type: 'image'
        * }
        *
        * The keyphrase groupId is assigned by the NLP engine and
        * enables the Highlighter to identify the correct ranges
        * in the Context when highlights are toggled.
        */
        appendImage: function (image) {
          var tile = document.createElement('cp-tile-image');

          tile.src = image.thumbnailSrc;
          tile.width = image.width;
          tile.height = image.height;
          tile.image = image;

          this.addTile(tile, image.keyword);
        },

        /**
        * Convenience method to append a file tile to the
        * gallery; creates a cp-tile-file element for the file
        * object added.
        *
        * @param Object file Representation of file to add; has the
        * format:
        * {
        *   thumbnailSrc: "<url of file thumbnail>",
        *   keyword: {
        *       text: "<keyphrase text>",
        *       groupId: "<keyphrase group ID>"
        *   },
        *   caption: "<file caption>",
        *   createdDate: <date in format '2014-09-08T10:05:15.497Z'>,
        *   type: 'file'
        * }
        *
        * The keyphrase groupId is assigned by the NLP engine and
        * enables the Highlighter to identify the correct ranges
        * in the Context when highlights are toggled.
        */
        appendFile: function (file) {
          var tile = document.createElement('cp-tile-file');

          tile.src = file.thumbnailSrc;
          tile.caption = file.caption;
          tile.createdDate = file.createdDate;
          tile.service = file.service;
          tile.file = file;

          this.addTile(tile, file.keyword);
        },

        getLayout: function () {
          return this.$.layout;
        },

        /* layout the wrapped cp-layout */
        layout: function () {
          this.$.layout.layout();
        },

        /* reset scroller to top */
        scrollToTop: function () {
          this.$.scroller.scrollTop = 0;
        },

        /* start the waiting sequence (fade in overlay) */
        wait: function () {
          var self = this;

          if (this.waiting) {
            return;
          }

          this.waiting = true;
          this.$.waiting.classList.remove('fadeout');
          this.$.waiting.classList.add('fadein');

          /* ensure that the waiting indicator is removed even if
             no new tiles are added */
          this.waitTimeout = setTimeout(function () {
            self.stopWaiting();
          }, TIMEOUT);
        },

        /* immediately fade out the waiting overlay */
        stopWaiting: function () {
          var self = this;

          if (!this.waiting) {
            return;
          }

          if (this.waitTimeout) {
            clearTimeout(this.waitTimeout);
            this.waitTimeout = null;
          }

          /* when the animation ends, set waiting=false */
          var animationEndCb = function () {
            self.waiting = false;
            self.layout();
            self.$.waiting.removeEventListener('animationend', animationEndCb);
            self.$.waiting.removeEventListener('webkitAnimationEnd', animationEndCb);
          };

          this.$.waiting.addEventListener('animationend', animationEndCb);
          this.$.waiting.addEventListener('webkitAnimationEnd', animationEndCb);

          this.$.waiting.classList.remove('fadein');
          this.$.waiting.classList.add('fadeout');
        },

        sliderChanged: function () {
          this.fire('slider-change');
        }
      });
    })();
  </script>
</polymer-element>
