<!--
scrolling image search results component; responsible for tracking
the state of any ongoing search, displaying waiting spinners, and
pushing new tiles into the wrapped layout
-->
<link rel="import" href="../bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="../bower_components/paper-slider/paper-slider.html">
<link rel="import" href="./cp-scroll.html">
<link rel="import" href="./cp-layout.html">
<link rel="import" href="./cp-tile-file.html">
<link rel="import" href="./cp-tile-image.html">
<link rel="import" href="./cp-tile-article.html">

<polymer-element name="cp-display">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      #preresults p {
        margin-bottom: 0;
      }

      #preresults-heading {
        margin-top: 2px;
        margin-bottom: 18px;
      }

      #preresults-welcome {
        margin-top: 26px;
      }

      #scroller {
        width: 100%;
        transition: height 0.2s linear 0.2s;
      }

      #results {
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        z-index: 500;
      }

      #waiting {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1000;
        -webkit-animation-duration: 0.25s;
        animation-duration: 0.25s;
        -webkit-animation-timing-function: ease-out;
        animation-timing-function: ease-out;
      }

      #waiting.fadein {
        -webkit-animation-name: fadein;
        animation-name: fadein;
      }

      #waiting.fadeout {
        -webkit-animation-name: fadeout;
        animation-name: fadeout;
      }

      #slider_wrapper {
        position: absolute;
        bottom: 0;
        width: 100%;
        align-items: center;
        height: 32px;
        background-color: #e6e6e6;
        transition: height 0.2s ease-out 0.2s;
      }

      #slider_wrapper:hover {
        height: 64px;
      }

      .full-size {
        /* -height of slider_wrapper */
        height: calc(100% - 32px);
      }

      .shrunk {
        /* -height of slider_wrapper:hover */
        height: calc(100% - 64px);
      }

      #label_wrapper {
        width: 90%;
        height: 32px;
        margin-left: 5%;
        margin-right: 5%;
      }

      #label_wrapper div {
        color: rgba(0, 0, 0, 0.46);
        font-size: 12px;
      }

      @-webkit-keyframes fadein {
        from { opacity: 0; }
        to   { opacity: 1; }
      }

      @-webkit-keyframes fadeout {
        from { opacity: 1; }
        to   { opacity: 0; }
      }

      [data-show="false"] {
        display: none !important;
      }

      paper-slider {
        width: 100%;
        max-height: 24px;
        min-height: 24px;
        box-sizing: border-box;
        margin-bottom: 8px;
      }

      /* slider colors (oh dear...) */
      /* bar */
      paper-slider::shadow #sliderBar::shadow #activeProgress {
        background-color: #31e0ce !important;
      }

      /* knob */
      paper-slider::shadow #sliderKnobInner {
        background-color: #31e0ce !important;
        border: none !important;
      }

      /* pin */
      paper-slider::shadow #sliderKnobInner::before {
        background-color: #31e0ce !important;
      }

      .hide {
        visibility: hidden;
      }

      .divider-top {
        border-top: thin solid black;
        padding-top: 16px;
        margin-top: 10px;
      }

      .vbox {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      .fill {
        width: 100%;
        height: 100%;
        background-color: #eee;
      }

      .message-area {
        text-align: center;
        width: 60%;
        box-sizing: border-box;
      }

      [data-visible="false"] {
        visibility: none;
      }

      [data-visible="true"] {
        visibility: visible;
      }
    </style>

    <!--
    states for this component:

    - preresults - no search initiated, displays welcome message
    - results - slider is shown with results (or empty results)
    -->

    <!-- never searched -->
    <div id="preresults" class="fill vbox"
         data-show="{{state === 'preresults'}}">
      <div class="message-area">
        <div><img src="../images/CP_Icon_large.png"></div>
        <p id="preresults-welcome">Welcome to</p>
        <h2 id="preresults-heading">Content Push</h2>
        <p class="divider-top">Start writing and we'll find content for you</p>
      </div>
    </div>

    <!-- no results -->
    <div id="noresults" class="fill vbox"
         data-show="{{!waiting && state === 'noresults'}}">
      <div class="message-area">
        <p>Sorry, we couldn't find good results</p>
        <p class="divider-top">You could try writing a little more</p>
      </div>
    </div>

    <!-- full page loader; can overlay image display -->
    <div id="waiting" class="fill vbox"
         data-show="{{waiting && state !== 'preresults'}}">
      <div class="message-area">
        <p>Your content is on the way...</p>
        <template if="{{waiting && state !== 'preresults'}}">
          <paper-spinner active></paper-spinner>
        </template>
      </div>
    </div>

    <!-- after results are found -->
    <div id="results" class="fill">
      <!-- image display (results) -->
      <cp-scroll id="scroller"
                 on-scrollend="{{onScrollerScrollend}}"
                 data-visible="{{state === 'results'}}"
                 class="full-size">
        <!-- results -->
        <cp-layout id="layout" on-layout="{{checkResultState}}"
                   data-visible="{{state === 'results'}}"></cp-layout>
      </cp-scroll>

      <div id="slider_wrapper" class="hide" vertical justified layout
           on-mouseover="{{onSliderMouseOver}}"
           on-mouseout="{{onSliderMouseOut}}">
        <!-- "widen the search" slider -->
        <paper-slider id="slider" min="1" max="100" value="50"
                      pin snaps step="1"
                      on-change="{{sliderChanged}}"
                      data-show="{{state !== 'preresults'}}">
        </paper-slider>

        <div id="label_wrapper" horizontal justified layout>
          <div>FOCUS</div>
          <div>WANDER</div>
        </div>
      </div>
    </div>
  </template>

  <script src="../bower_components/lodash/dist/lodash.js"></script>
  <script src="./cp-constants.js"></script>
  <script src="./cp-filter-deduplicate.js"></script>

  <script>
    (function () {
      Polymer({
        /* state of the results; 'preresults', 'noresults' or 'results' */
        state: 'preresults',

        /* whether we are waiting for a tile to load or not */
        waiting: false,

        created: function () {
          this.urlDeduplicator = new FilterDeduplicate();
        },

        ready: function () {
          /* timeout to clear the waiting element if no tile is loaded
             successfully */
          this.waitTimeout = null;
        },

        /**
         * Set criteria for filtering the content of the display.
         *
         * @param {object} criteria Criteria for the filter
         * @param {object} criteria.activeKeywords an array of active keywords
         *
         * Right now, the first keyword in the keywordInfo.keywords
         * array is used as the filter. Any tile whose keyword.text
         * property matches this active keyword and has a type
         * matching one of the members of "types" will be displayed.
         */
        setFilter: function (criteria) {
          var self = this;

          if (!criteria.activeKeywords) {
            return;
          }

          this.setSliderRange(criteria.activeKeywords);

          /* only show the selected number of the active keywords */
          var numKeywords = this.$.slider.immediateValue;
          var keywordsToUse = criteria.activeKeywords.slice(0, numKeywords);

          var keywords = keywordsToUse.map(function (keyword) {
            return keyword.text;
          });

          criteria.types = criteria.types || [];

          /* set the filter on the layout to the current keyphrase */
          this.$.layout.setFilter(function (tile) {
            var keywordMatches = false;

            for (var i = 0; i < tile.keywords.length; i++) {
              var index = keywords.indexOf(tile.keywords[i].text);
              if (index !== -1) {
                keywordMatches = true;
                tile.keywords[i] = criteria.activeKeywords[index];
              }
            }

            if (!keywordMatches) {
              return false;
            }

            if (tile.type === 'image') {
              var imageSources = criteria.sources['Images'];

              if (typeof imageSources !== 'undefined' &&
                  Object.keys(imageSources).length > 0) {
                var tileSource = imageSources.sources[tile.sourceName];

                if (typeof tileSource === 'undefined' ||
                    tileSource.enabled === false) {
                  return false;
                }
              }
            } else
            if (tile.type === 'article') {
              var articleSources = criteria.sources['Articles'];

              if (typeof articleSources !== 'undefined' &&
                  Object.keys(articleSources).length > 0) {
                var tileSource = articleSources.sources[tile.sourceName];

                if (typeof tileSource === 'undefined' ||
                    tileSource.enabled === false) {
                  return false;
                }
              }
            }

            var typeMatches;
            /* no types criteria, so always matches */
            if (criteria.types.length === 0) {
              typeMatches = true;
            } else {
              typeMatches = _.contains(criteria.types, tile.type);
            }

            return keywordMatches && typeMatches;
          });

          var hidden = this.$.slider_wrapper.classList.contains('hide');
          if (keywords.length > 0 && hidden) {
            this.$.slider_wrapper.classList.remove('hide');
          } else
          if (keywords.length <= 0 && !hidden) {
            console.log('CP-DISPLAY:hiding');
            this.state = 'noresults';
            this.$.slider_wrapper.classList.add('hide');
          }
        },

        /**
         * Add results to the layout.
         *
         * Each result in the results array should look like:
         * {
         *   src: <url of image>,
         *   keyword: {
         *     text: <keyphrase text>,
         *     groupId: <keyphrase groupId>
         *   },
         *   meta: { ... metadata ... },
         *   caption: <image caption>,
         *   source: <url of image source>
         * }
         */
        receiveResults: function (results) {
          for (var i = 0; i < results.length; i++) {
            if (results[i].type === 'image') {
              this.appendImage(results[i]);
            } else if (results[i].type === 'file') {
              this.appendFile(results[i]);
            } else if (results[i].type === 'article') {
              this.appendArticle(results[i]);
            }
          }
        },

        onScrollerScrollend: function () {
          this.fire('moreresults');
        },

        /**
         * Register a cp-tile* element. If a tile already exists in
         * the layout with the same source as tile, just append
         * keyword to its array of keywords; if not,
         * add a cp-tile* element to the layout, attaching handlers
         * at the same time and associating the keyword with it.
         *
         * @param {DOMElement} tile cp-tile* element to add to the
         * layout inside this display.
         * @param {string} keyword Keyword to associate with this tile.
         */
        registerTile: function (tile, keyword) {
          var self = this;

          /* is a tile with this source already in the layout?
             if it is, we just want to add a new keyword to it */
          var existingTile = this.$.layout.getTileBySource(tile.source);

          if (existingTile && !_.include(existingTile.keywords, keyword)) {
            existingTile.keywords.push(keyword);
          } else if (this.urlDeduplicator.test(tile.source)) {
            this.urlDeduplicator.addComparisonValue(tile.source);

            tile.keywords = [keyword];

            tile.addEventListener('mouseover', function () {
              self.fire('mouse-over', tile.keywords);
            });

            tile.addEventListener('mouseout', function () {
              self.fire('mouse-out', tile.keywords);
            });

            tile.addEventListener('click', function () {
              self.fire('mouse-down', tile);
            });

            this.$.layout.addTile(tile);
          }
        },

        /* when a layout happens, check whether any tiles are visible
           and stop waiting indicator if they are */
        checkResultState: function () {
          if (this.$.layout.getCountVisibleTiles() > 0) {
            this.state = 'results';
            this.stopWaiting();
          } else if (!this.waiting && this.$.layout.tilesLoading < 1) {
            this.state = 'noresults';
          }
        },

        onSliderMouseOver: function () {
          this.$.scroller.classList.remove('full-size');
          this.$.scroller.classList.add('shrunk');
        },

        onSliderMouseOut: function () {
          this.$.scroller.classList.remove('shrunk');
          this.$.scroller.classList.add('full-size');
        },

        /**
        * Convenience method to append an image tile to the
        * gallery; creates a cp-tile-image element for the image
        * object added.
        *
        * @param Object image Representation of image to add; has the
        * format:
        * {
        *   thumbnailSrc: "<url of image thumbnail>",
        *   width: <width of full-size image>,
        *   height: <height of full-size image>,
        *   keyword: {
        *       text: "<keyphrase text>",
        *       groupId: "<keyphrase group ID>"
        *   },
        *   type: 'image'
        * }
        *
        * The keyphrase groupId is assigned by the NLP engine and
        * enables the Highlighter to identify the correct ranges
        * in the Context when highlights are toggled.
        */
        appendImage: function (image) {
          var tile = document.createElement('cp-tile-image');

          tile.src = image.thumbnailSrc;
          tile.width = image.width;
          tile.height = image.height;
          tile.sourceName = image.sourceName;
          tile.source = image.source;
          tile.image = image;

          this.registerTile(tile, image.keyword);
        },

        /**15px
        * Convenience method to append a file tile to the
        * gallery; creates a cp-tile-file element for the file
        * object added.
        *
        * @param Object file Representation of file to add; has the
        * format:
        * {
        *   thumbnailSrc: "<url of file thumbnail>",
        *   keyword: {
        *       text: "<keyphrase text>",
        *       groupId: "<keyphrase group ID>"
        *   },
        *   caption: "<file caption>",
        *   createdDate: <date in format '2014-09-08T10:05:15.497Z'>,
        *   type: 'file'
        * }
        *
        * The keyphrase groupId is assigned by the NLP engine and
        * enables the Highlighter to identify the correct ranges
        * in the Context when highlights are toggled.
        */
        appendFile: function (file) {
          var tile = document.createElement('cp-tile-file');

          tile.src = file.thumbnailSrc;
          tile.caption = file.caption;
          tile.createdDate = file.createdDate;
          tile.service = file.service;
          tile.source = file.source;
          tile.sourceName = file.sourceName;
          tile.file = file;

          this.registerTile(tile, file.keyword);
        },

        /**
        * Convenience method to append an article tile to the
        * gallery; creates a cp-tile-article element for the article
        * object added.
        *
        * @param Object article Representation of article to add; has the
        * format:
        * {
        *   thumbnailSrc: "<url of article image thumbnail>",
        *   src: "<url of article image>",
        *   keyword: {
        *       text: "<keyphrase text>",
        *       groupId: "<keyphrase group ID>"
        *   },
        *   caption: "<file caption>",
        *   source: "http://website.url/",
        *   snippet: "snippet of text from the article",
        *   type: "article"
        * }
        *
        * The keyphrase groupId is assigned by the NLP engine and
        * enables the Highlighter to identify the correct ranges
        * in the Context when highlights are toggled.
        */
        appendArticle: function (article) {
          var tile = document.createElement('cp-tile-article');

          tile.src = article.thumbnailSrc;
          tile.caption = article.caption;
          tile.snippet = article.snippet;
          tile.source = article.source;
          tile.sourceName = article.sourceName;
          tile.article = article;

          this.registerTile(tile, article.keyword);
        },

        getLayout: function () {
          return this.$.layout;
        },

        /* layout the wrapped cp-layout */
        layout: function () {
          this.$.layout.layout();
        },

        /* reset scroller to top */
        scrollToTop: function () {
          this.$.scroller.scrollTop = 0;
        },

        /* start the waiting sequence (fade in overlay) */
        wait: function () {
          var self = this;

          if (this.waiting) {
            return;
          }

          this.waiting = true;
          this.$.waiting.classList.remove('fadeout');
          this.$.waiting.classList.add('fadein');

          /* ensure that the waiting indicator is removed even if
             no new tiles are added */
          this.waitTimeout = setTimeout(function () {
            self.stopWaiting();
          }, CP_CONSTANTS.TIMEOUT);
        },

        /* immediately fade out the waiting overlay; show noresults
           if there are no results */
        stopWaiting: function () {
          var self = this;

          if (!this.waiting) {
            return;
          }

          if (this.waitTimeout) {
            clearTimeout(this.waitTimeout);
            this.waitTimeout = null;
          }

          /* when the animation ends, set waiting=false */
          var animationEndCb = function () {
            self.waiting = false;
            self.layout();
            self.$.waiting.removeEventListener('animationend', animationEndCb);
            self.$.waiting.removeEventListener('webkitAnimationEnd', animationEndCb);
          };

          this.$.waiting.addEventListener('animationend', animationEndCb);
          this.$.waiting.addEventListener('webkitAnimationEnd', animationEndCb);

          this.$.waiting.classList.remove('fadein');
          this.$.waiting.classList.add('fadeout');
        },

        sliderChanged: function (e) {
          this.fire('slider-change');
        },

        /* set the slider range to the number of keywords available
           in the current context; the position of the slider is
           set based on the position of the slider with the previous
           number of keywords: e.g. if there were 4 active keywords
           before this method call, and 2 were selected by the slider,
           set the slider value to select 50% of the new set of
           keywords */
        setSliderRange: function (newKeywords) {
          /* don't do anything if the number of newKeywords matches
             the max value of the slider */
          if (newKeywords.length === this.$.slider.max) {
            return;
          }

          var currentValueFraction = Math.max(this.$.slider.immediateValue, 1) /
                                     Math.max(this.$.slider.max, 1);

          var newValue = Math.floor(
            newKeywords.length * currentValueFraction
          );

          this.$.slider.value = Math.max(newValue, 1);
          this.$.slider.max = Math.max(newKeywords.length, 1);
        }
      });
    })();
  </script>
</polymer-element>
