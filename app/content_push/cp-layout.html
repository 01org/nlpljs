<link rel="import" href="../bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="./cp-tile-file.html">
<link rel="import" href="./cp-tile-image.html">

<polymer-element name="cp-layout">
  <template>
    <style>
      :host {
        display: block;
      }

      #container {
        position: relative;
      }

      cp-tile-image, cp-tile-file {
        position: absolute;
        transition-property: top, left, opacity;
        transition-duration: 0.25s, 0.25s, 0.25s;
        transition-timing-function: ease-out, ease-out, ease-out;
      }

      #loading, #noresults {
        width: 100%;
        text-align: center;
        padding-top: 2em;
      }

      /* when a cp-tile-image displays inside this element, a margin
         appears to be added below the meta paragraph; I couldn't track
         this down, so this work-around removes that margin for
         cp-tile-images only in the context of a this element */
      cp-tile-image::shadow #meta {
        margin: 0 0 3px 0;
      }

      [data-show="false"] {
        display: none !important;
      }
    </style>

    <div id="container" data-show="{{!noresults}}"></div>

    <div id="noresults" data-show="{{tilesLoading < 1 && noresults}}">
      <p>Sorry, we couldn't find anything.</p>
    </div>

    <div id="loading" data-show="{{tilesLoading > 0}}">
      <paper-spinner active></paper-spinner>
    </div>
  </template>

  <script src="../bower_components/lodash/dist/lodash.js"></script>
  <script src="cp-layout-frame-chooser.js"></script>
  <script src="cp-layout-generator.js"></script>

  <script>
    (function () {
      var NARROW_NUM_COLS = 4;
      var WIDE_NUM_COLS = 8;

      // when gallery >= this width, switch to WIDE_NUM_COLS
      var WIDE_BREAKPOINT = 456;

      /*
      length of the side of a row/column for the purpose of
      choosing a frame
      */
      var FRAME_CELL_SIDE = 54;

      /*
      base URL for Google's image resizer (undocumented);
      see http://carlo.zottmann.org/2013/04/14/google-image-resizer/
      */
      var RESIZER_BASE_URL = 'https://images1-focus-opensocial.googleusercontent.com/gadgets/proxy';

      var makeImageLoadHandler = function (layout, elt) {
        return function () {
          layout.frameImage(elt);
          layout.$.container.appendChild(elt);
          layout.layout();

          layout.fire('childrenchanged', {
            added: elt,
            numChildren: layout.getChildren().length,
            parent: layout
          });

          layout.countChildrenLoading--;
          layout.fireChildrenLoading();
          elt.counted = true;
        }
      };

      var makeImageErrorHandler = function (layout, elt) {
        return function () {
          layout.countChildrenLoading--;
          layout.fireChildrenLoading();
          elt.counted = true;
        }
      };

      var makeImageTimeoutHandler = function (layout, elt) {
        return function () {
          if (!elt.counted) {
            layout.countChildrenLoading--;
            layout.fireChildrenLoading();
            elt.counted = true;
          }
        };
      };

      var makeImageMouseoverHandler = function (layout, image) {
        return function () {
          layout.fire('mouse-over', image.keyphrase)
        };
      };

      var makeImageMouseoutHandler = function (layout, image) {
        return function () {
          layout.fire('mouse-out', image.keyphrase);
        };
      };

      Polymer({
        /* filter which determines the tiles to show; this is applied
           on each layout() call to determine the visible tiles;
           if this function returns true, the tile is shown */
        filter: null,

        created: function () {
          this.frameChooser = new FrameChooser(FRAME_CELL_SIDE, FRAME_CELL_SIDE);
          this.layoutGenerator = new LayoutGenerator();
          this.numColumns = NARROW_NUM_COLS;

          /* cached height and width, to reduce the number of events fired */
          this.lastMeasuredHeight = 0;
          this.lastMeasuredWidth = 0;

          /* count of the number of tiles currently loading */
          this.tilesLoading = 0;

          /* set to true if there are noresults visible */
          this.noresults = false;
        },

        /* set number of columns based on the gallery width */
        setLayoutParams: function () {
          var width = this.offsetWidth;

          if (width >= WIDE_BREAKPOINT) {
            this.numColumns = WIDE_NUM_COLS;
          }
          else {
            this.numColumns = NARROW_NUM_COLS;
          }
        },

        domReady: function () {
          this.setLayoutParams();
        },

        setFilter: function (filter) {
          this.filter = filter;
          this.layout();
        },

        /**
         * Return all child cp-tile* elements which are visible.
         */
        getVisibleTiles: function () {
          return this.$.container.querySelectorAll('[data-tile="true"][data-show="true"]');
        },

        /**
         * Return all child cp-tile* elements, including the hidden ones.
         */
        getAllTiles: function () {
          return this.$.container.querySelectorAll('[data-tile="true"]');
        },

        /* add the tile to the layout if it loaded OK */
        tileReady: function (tile) {
          // loaded is false if the image failed to load
          if (tile.loaded) {
            this.frameTile(tile);
            tile.setAttribute('data-tile', 'true');
            this.$.container.appendChild(tile);
          }

          this.tilesLoading--;
          this.fireLoadEvent();
          this.layout();
        },

        /**
        * Convenience method to add a tile to the layout.
        *
        * @param {cp-tile} tile Tile to add; must have the following
        * properties:
        *   - loaded: true if the tile can be added to the layout
        *   - done: true if the tile is finished preparing itself
        *   - width
        *   - height
        *   - ratio
        *
        * @fires loading or loaddone
        */
        addTile: function (tile) {
          var self = this;

          this.tilesLoading++;
          this.fireLoadEvent();

          if (tile.loaded) {
            this.tileReady(tile);
          } else {
            tile.addEventListener('done', function () {
              self.tileReady(tile);
            });
          }
        },

        /**
         * Add the appropriate frame to the cp-tile*.
         *
         * @param DOMElement tile cp-tile* element
         */
        frameTile: function (tile) {
          var frame = this.frameChooser.choose(tile);
          tile.setAttribute('data-frame', frame.name);
          tile.setAttribute('data-columns', frame.columns);
          tile.setAttribute('data-rows', frame.rows);
        },

        /**
         * Apply layout to cp-tile*s which satisfy the current filter.
         */
        layout: function () {
          var tiles = this.getAllTiles();

          /* convert tiles into shapes */
          var shapes = [];

          var hideTile;

          for (var i = 0; i < tiles.length; i++) {
            var tile = tiles[i];

            hideTile = (this.filter && !this.filter(tile));
            tile.setAttribute('data-show', !hideTile);

            if (!hideTile) {
              shapes.push({
                elt: tile,
                width: parseInt(tile.getAttribute('data-columns'), 10),
                height: parseInt(tile.getAttribute('data-rows'), 10)
              });
            }
          }

          /* no shapes means no results */
          this.noresults = (shapes.length === 0 && this.tilesLoading < 1);
          if (this.noresults) {
            return;
          }

          var cellSide = this.offsetWidth / this.numColumns;
          this.setLayoutParams();

          var layout = this.layoutGenerator.generate(shapes, this.numColumns);

          var shape, position, elt, firstCol, width, x,
              firstRow, height, y;

          _.each(layout.placements, function (placement) {
            shape = placement.shape;
            position = placement.position;

            width = position.columns.length * cellSide;
            firstCol = _.first(position.columns);
            x = firstCol * cellSide;

            height = position.rows.length * cellSide;
            firstRow = _.first(position.rows);
            y = firstRow * cellSide;

            shape.elt.style.left = x + 'px';
            shape.elt.style.top = y + 'px';
            shape.elt.style.width = width + 'px'
            shape.elt.style.height = height + 'px';
          });

          /* set the container height */
          var height = layout.grid.length * cellSide;
          this.$.container.style.height = height + 'px';

          /* fire an event to notify listeners that this element's
             height changed */
          var width = this.offsetWidth;
          var height = this.offsetHeight;

          if (this.lastMeasuredWidth !== width ||
              this.lastMeasuredHeight !== height) {
            this.lastMeasuredWidth = width;
            this.lastMeasuredHeight = height;

            this.fire('resize', {
              width: width,
              height: height
            });
          }

          this.fire('layout');
        },

        /**
         * Fire a "loading" or "loaddone" event, depending on the
         * number of children pending.
         */
        fireLoadEvent: function () {
          if (this.tilesLoading > 0) {
            this.fire('loading');
          } else {
            this.fire('loaddone');
          }
        }
      })
    })();
  </script>
</polymer-element>
