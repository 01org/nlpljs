<link rel="import" href="../bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="./cp-tile-file.html">
<link rel="import" href="./cp-tile-image.html">

<polymer-element name="cp-layout">
  <template>
    <style>
      :host {
        display: block;
      }

      #container {
        position: relative;
      }

      [data-tile="true"] {
        position: absolute;
        transition-property: top, left, opacity;
        transition-duration: 0.25s, 0.25s, 0.25s;
        transition-timing-function: ease-out, ease-out, ease-out;
      }

      #loading {
        width: 100%;
        text-align: center;
        padding-top: 2em;
      }

      [data-show="false"] {
        display: none !important;
      }
    </style>

    <div id="container" data-show="{{visibleTiles > 0}}"
         data-total-tiles="{{totalTiles}}"
         data-visible-tiles="{{visibleTiles}}"
         data-loading-tiles="{{tilesLoading}}">
    </div>

    <div id="loading" data-show="{{tilesLoading > 0}}">
      <template if="{{tilesLoading > 0}}">
        <paper-spinner active></paper-spinner>
      </template>
    </div>
  </template>

  <script src="../bower_components/lodash/dist/lodash.js"></script>
  <script src="cp-layout-frame-chooser.js"></script>
  <script src="cp-layout-generator.js"></script>

  <script>
    (function () {
      var NARROW_NUM_COLS = 4;
      var WIDE_NUM_COLS = 8;

      // when gallery >= this width, switch to WIDE_NUM_COLS
      var WIDE_BREAKPOINT = 456;

      /*
      length of the side of a row/column for the purpose of
      choosing a frame
      */
      var FRAME_CELL_SIDE = 54;

      Polymer({
        /* filter which determines the tiles to show; this is applied
           on each layout() call to determine the visible tiles;
           if this function returns true, the tile is shown */
        filter: null,

        created: function () {
          this.frameChooser = new FrameChooser(FRAME_CELL_SIDE, FRAME_CELL_SIDE);
          this.layoutGenerator = new LayoutGenerator();
          this.numColumns = NARROW_NUM_COLS;

          /* cached height and width, to reduce the number of events fired */
          this.lastMeasuredHeight = 0;
          this.lastMeasuredWidth = 0;

          /* count of the number of tiles currently loading */
          this.tilesLoading = 0;

          /* tiles currently visible */
          this.visibleTiles = 0;

          /* layout promise */
          this.layoutInProgress = Promise.resolve();

          /* cached source attributes; used to quickly determine
             whether a tile exists for a source */
          this.tileSources = {};
        },

        /* set number of columns based on the gallery width */
        setLayoutParams: function () {
          var width = this.offsetWidth;

          if (width >= WIDE_BREAKPOINT) {
            this.numColumns = WIDE_NUM_COLS;
          } else {
            this.numColumns = NARROW_NUM_COLS;
          }
        },

        domReady: function () {
          this.setLayoutParams();
        },

        setFilter: function (filter) {
          this.filter = filter;
          this.layout();
        },

        /**
         * Return count of child cp-tile* elements which are visible.
         */
        getCountVisibleTiles: function () {
          return this.visibleTiles;
        },

        /**
         * Return all child cp-tile* elements, including the hidden ones.
         */
        getAllTiles: function () {
          return this.$.container.querySelectorAll('[data-tile="true"]');
        },

        /**
         * Search for a tile with "source" attribute set to value;
         * returns the found tile; or if not found, returns null
         */
        getTileBySource: function (value) {
          return this.tileSources[value] || null;
        },

        /* add the tile to the layout if it loaded OK */
        tileReady: function (tile) {
          this.tilesLoading -= 1;

          /* loaded is false if the image failed to load */
          if (tile.loaded) {
            this.frameTile(tile);

            /* record the source URL of the tile in the cache */
            this.tileSources[tile.source] = tile;

            tile.setAttribute('data-tile', 'true');

            if (this.filter && !this.filter(tile)) {
              tile.setAttribute('data-show', 'false');
            }

            this.$.container.appendChild(tile);
            this.fire('tileadded', tile);
          }

          this.fireLoadEvent();
          this.layout();
        },

        /**
        * Convenience method to add a tile to the layout.
        *
        * @param {cp-tile} tile Tile to add; must have the following
        * properties:
        *   - loaded: true if the tile can be added to the layout
        *   - done: true if the tile is finished preparing itself
        *   - width
        *   - height
        *   - ratio
        *
        * @fires loading or loaddone
        */
        addTile: function (tile) {
          var self = this;

          this.tilesLoading += 1;
          this.fireLoadEvent();

          if (tile.done) {
            this.tileReady(tile);
          } else {
            tile.addEventListener('done', function () {
              if (tile.type === 'file') {
                console.error('CP-LAYOUT: setting "done" handler on ' +
                              'file tile; handler will never fire');
              }
              self.tileReady(tile);
            });
          }
        },

        /**
         * Add the appropriate frame to the cp-tile*. If tile already
         * has a "frame" property referencing a frame object,
         * the frame is set to that.
         *
         * @param DOMElement tile cp-tile* element
         */
        frameTile: function (tile) {
          var frame = tile.frame || this.frameChooser.choose(tile);
          tile.setAttribute('data-frame', frame.name);
          tile.setAttribute('data-columns', frame.columns);
          tile.setAttribute('data-rows', frame.rows);
        },

        /**
         * Apply layout to cp-tile*s which satisfy the current filter.
         */
        doLayout: function () {
          /* assume all tiles are hidden by default */
          var visibleTiles = 0;

          var totalTiles = 0;

          var tiles = this.getAllTiles();

          /* convert tiles into shapes */
          var shapes = [];

          var hideTile;

          for (var i = 0; i < tiles.length; i++) {
            totalTiles++;

            var tile = tiles[i];

            hideTile = (this.filter && !this.filter(tile));

            /* only show loaded tiles */
            hideTile = (hideTile && tile.loaded);

            tile.setAttribute('data-show', !hideTile);

            if (!hideTile) {
              shapes.push({
                elt: tile,
                width: parseInt(tile.getAttribute('data-columns'), 10),
                height: parseInt(tile.getAttribute('data-rows'), 10)
              });

              visibleTiles++;
            }
          }

          this.visibleTiles = visibleTiles;
          this.totalTiles = totalTiles;

          var cellSide = this.offsetWidth / this.numColumns;
          this.setLayoutParams();

          var layout = this.layoutGenerator.generate(shapes, this.numColumns);

          var shape, position, elt, firstCol, width, x,
              firstRow, height, y;

          _.each(layout.placements, function (placement) {
            shape = placement.shape;
            position = placement.position;

            width = position.columns.length * cellSide;
            firstCol = position.columns[0];
            x = firstCol * cellSide;

            height = position.rows.length * cellSide;
            firstRow = position.rows[0];
            y = firstRow * cellSide;

            shape.elt.style.left = x + 'px';
            shape.elt.style.top = y + 'px';
            shape.elt.style.width = width + 'px'
            shape.elt.style.height = height + 'px';
          });

          /* set the container height */
          var height = layout.grid.length * cellSide;
          this.$.container.style.height = height + 'px';

          /* fire an event to notify listeners that this element's
             height changed */
          var width = this.offsetWidth;
          var height = this.offsetHeight;

          if (this.lastMeasuredWidth !== width ||
              this.lastMeasuredHeight !== height) {
            this.lastMeasuredWidth = width;
            this.lastMeasuredHeight = height;

            this.fire('resize', {
              width: width,
              height: height
            });
          }

          this.fire('layout');
        },

        layout: function () {
          var self = this;

          this.layoutInProgress = this.layoutInProgress.then(
            function () {
              return new Promise(function (resolve, reject) {
                var layoutDoneCb = function () {
                  resolve();
                  self.removeEventListener('layout', layoutDoneCb);
                };

                self.addEventListener('layout', layoutDoneCb);

                self.doLayout();
              });
            }
          );

          return this.layoutInProgress;
        },

        /**
         * Fire a "loading" or "loaddone" event, depending on the
         * number of children pending.
         */
        fireLoadEvent: function () {
          if (this.tilesLoading > 0) {
            this.fire('loading');
          } else {
            this.fire('loaddone');
          }
        }
      })
    })();
  </script>
</polymer-element>
