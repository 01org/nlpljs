<!--
 - cp-document
 -->

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel='import' href='./cp-scrollwatcher.html'>
<link rel='import' href='./cp-keyword-highlighter.html'>
<link rel="import" href="./cp-globals.html">

<polymer-element
  name="cp-document"
  on-mouseoverimage="{{onMouseOverImage}}"
  on-mouseoutimage="{{onMouseOutImage}}">
  <template>
    <style>
      :host {
        position: relative;
      }

      #iframe {
        position: absolute;
        display: block;
        background-color: #f0f0f0;
        height: 100%;
        width: 100%;
        border: none;
      }

      #iframe.nopointerevents {
        pointer-events: none;
      };
    </style>
    <iframe id="iframe"></iframe>
    <cp-keyword-highlighter id="highlighter"></cp-keyword-highlighter>
    <cp-scrollwatcher id="scrollwatcher"></cp-scrollwatcher>
    <cp-globals id="globals"></cp-globals>
  </template>
  <script>
    (function () {
      // private *static* functions and constants
      var LINE_CLASS = 'kix-lineview';        /* Handle to the current Page */
      var LINE_SELECTOR = '.kix-lineview';
      var SCROLLING_ELEMENT_SELECTOR = '.kix-appview-editor';
      var docsHomeFixed = false; // only once per instance of Content Push tab

      /**
       * find ancestor of node that has className
       * for finding the ancestor with .kix-lineview of whatever line has changed
       */
      var findAncestor = function (node, className) {
        var retVal = null;

        var thisNode = node;
        var cssSelectorNotFound = true;

        while (cssSelectorNotFound && thisNode && thisNode.nodeName != 'BODY') {
          cssSelectorNotFound = !thisNode.classList.contains(className);
          if (cssSelectorNotFound) {
            // move into parent node
            thisNode = thisNode.parentNode;
          } else {
            // finished
            retVal = thisNode;
          }
        }

        return retVal;
      };

      /**
       * find the docs home button and fix it to redirect the tab
       * instead of staying inside the iframe
       */
      var fixDocsHomeLink = function (self) {
        var docsHome = self.$.iframe.contentDocument.querySelectorAll('a[data-tooltip="Docs home"]');
        if (docsHome.length>0) {
          var href = docsHome[0].getAttribute('href');
          docsHome[0].setAttribute('href', '#');
          docsHome[0].addEventListener('click', function () {
            window.location.replace(href);
          });
          docsHomeFixed = true;
        }
      };

      var observeDocumentChanges = function (self) {
        var observer = new MutationObserver(function (mutations, observerInstance) {
          if (!docsHomeFixed) {
            fixDocsHomeLink(self);
          }

          for (var i = 0; i < mutations.length; i++) {
            var mutation = mutations[i];
            var newNodes = mutation.addedNodes;
            var removedNodes = mutation.removedNodes;

            if (removedNodes !== null) {
              for (var j = 0; j < removedNodes.length; j++) {
                var thisNode = removedNodes[j];
                if (thisNode) {
                  if (typeof thisNode.classList !== 'undefined' &&
                      thisNode.classList.contains(LINE_CLASS) &&
                      thisNode.getAttribute('cp_line_id') !== null &&
                      self.$.scrollwatcher.isNodeVisible(thisNode)) {
                    console.log('MO:removed line');

                    self.$.scrollwatcher.removeTargetNode(thisNode);

                    if (self.editOverTimer !== null) {
                      clearTimeout(self.editOverTimer);
                    }

                    self.editOverTimer = setTimeout(function () {
                      self.$.scrollwatcher.getVisibleNodes(getContext, self);
                    }, self.EDITOVERTIMEOUT);
                  }
                }
              }
            }

            if (newNodes !== null) {
              for (var j = 0; j < newNodes.length; j++) {
                var thisNode = newNodes[j];
                if (thisNode) {
                  if (thisNode.nodeName === 'SPAN') {
                    var line = findAncestor(thisNode, LINE_CLASS);

                    if (line !== null &&
                        line.getAttribute('cp_line_id') !== null &&
                        self.$.scrollwatcher.isNodeVisible(line) &&
                        line.innerHTML.indexOf('keyword-highlight') === -1) {
                      console.log('MO:editing line');

                      if (self.editOverTimer !== null) {
                        clearTimeout(self.editOverTimer);
                      }

                      self.editOverTimer = setTimeout(function () {
                        self.$.scrollwatcher.getVisibleNodes(getContext, self);
                      }, self.EDITOVERTIMEOUT);
                    }
                  }
                  else if (typeof thisNode.classList !== 'undefined' &&
                           thisNode.classList.contains(LINE_CLASS) &&
                           thisNode.getAttribute('cp_line_id') === null) {
                    console.log('MO:new line');
                    addIdToLine(thisNode, self.lineIdAccumulator);
                    self.lineIdAccumulator++;

                    self.$.scrollwatcher.addTargetNode(thisNode);

                    if (self.$.scrollwatcher.isNodeVisible(thisNode)) {
                      if (self.editOverTimer !== null) {
                        clearTimeout(self.editOverTimer);
                      }

                      self.editOverTimer = setTimeout(function () {
                        self.$.scrollwatcher.getVisibleNodes(getContext, self);
                      }, self.EDITOVERTIMEOUT);
                    }
                  }
                }
              }
            }
          }
        });

        // Configuration of the observer:
        var config = {
          attributes: false,
          childList: true,
          subtree: true,
          characterData: false
        };

        // Pass in the target node, as well as the observer options
        observer.observe(self.$.iframe.contentDocument, config);
      };

      var handleIframeLoad = function (self) {
        var lines =
          self.$.iframe.contentDocument.querySelectorAll(LINE_SELECTOR);

        var editor =
          self.$.iframe.contentDocument.querySelector(SCROLLING_ELEMENT_SELECTOR);

        self.$.highlighter.targetElement = self.$.iframe.contentDocument;

        self.$.scrollwatcher.setScrollableNode(editor);
        self.$.scrollwatcher.addOnScrollListener(getContext, self);

        for (var i = 0; i < lines.length; i++) {
          addIdToLine(lines[i], self.lineIdAccumulator);
          self.lineIdAccumulator++;

          self.$.scrollwatcher.addTargetNode(lines[i]);
        }

        self.$.scrollwatcher.getVisibleNodes(getContext, self);

        observeDocumentChanges(self);
      };

      var addIdToLine = function (line, value) {
        var lineIdAtt = document.createAttribute('cp_line_id');

        lineIdAtt.value = value;
        line.setAttributeNode(lineIdAtt);
      };

      var sendToEpNlp = function (self, message) {
        console.log('CP-DOCUMENT:sending message to ep-nlp:', message);
        self.nlpPort.postMessage(message);
      };

      var getContext = function (context, self) {
        sendToEpNlp(self, {
          component: 'nlp',
          message: {
            type: 'newcontext'
          }
        });

        for (var i = 0; i < context.length; i++) {
          var lineId;
          var prevLineId = -1;

          lineId = context[i].getAttribute('cp_line_id');

          if (i > 0) {
            prevLineId = context[i - 1].getAttribute('cp_line_id');
          }

          sendToEpNlp(self, {
            component: 'nlp',
            message: {
              type: 'lineadded',
              data: {
                lineId: lineId,
                prevLineId: prevLineId,
                text: context[i].innerText
              }
            }
          });
        }

        sendToEpNlp(self, {
          component: 'nlp',
          message: {
            type: 'processcontext'
          }
        });

        self.fire('nlpstart');

        sendToEpNlp(self, {
          component: 'nlp',
          message: {
            type: 'getkeywords'
          }
        });
      };

      /**
       * Add an image card (gallery) for the current page;
       * if the image card exists for this page already, do not
       * add the element, but just set the keywordInfo.
       */
      var setKeywordInfo = function (self, keywordInfo) {
        self.keywordInfo = keywordInfo;
        self.fire('newkeywordinfo', {keywordInfo: keywordInfo});

        self.$.highlighter.clear();
        self.$.highlighter.prepare(keywordInfo.ranges);

      };

      Polymer({
        // functions and properties used in API and bindings
        // life cycle handlers
        EDITOVERTIMEOUT: 3000,
        editOverTimer: null,

        created: function () {
          this.nlpPort = null;
          this.lineIdAccumulator = 0;

          // currently active keywords
          this.keywordInfo = {
            keywords: [],
            ranges: []
          };
        },

        ready: function () {
          var self = this;
          this.$.iframe.src = this.$.globals.data.iframeurl;

          this.$.iframe.onload = function () {
            handleIframeLoad(self);
          };

          if (this.nlpPort === null) {
            console.log('CP-DOCUMENT: connecting to ep-nlp');
            this.nlpPort = chrome.runtime.connect(
              this.$.globals.data.app_id,
              { name: 'nlp' }
            );

            console.log('CP-DOCUMENT: connected to ep-nlp:', this.nlpPort);
            this.nlpPort.onMessage.addListener(function (detail) {
              console.log('CP-DOCUMENT: message from ep-nlp:', detail);
              if (detail.component === 'nlp') {
                if (detail.message.type === 'keywordlist') {
                  setKeywordInfo(self, detail.message.data);
                  self.fire('nlpstop');
                }
              }
            });

            var message = {
              component: 'nlp',
              message: {
                type: 'initialize'
              }
            };

            console.log('CP-DOCUMENT: message to ep-nlp:', message);
            this.nlpPort.postMessage(message);
          }
        },

        // API functions
        enablePointerEvents: function () {
          this.$.iframe.classList.remove('nopointerevents');
        },

        disablePointerEvents: function () {
          this.$.iframe.classList.add('nopointerevents');
        },

        // propertyChanged handlers
        iframeurlChanged: function (oldValue, newValue) {
          this.$.iframe.src = newValue;
        },

        // event handlers

        onMouseOverImage: function (e) {
          for (var i = 0; i < e.detail.length; i++) {
            this.$.highlighter.turn(e.detail[i].groupId, 'on');
          }
        },

        onMouseOutImage: function (e) {
          for (var i = 0; i < e.detail.length; i++)
            this.$.highlighter.turn(e.detail[i].groupId, 'off');
        },

      }); // Polymer()
    })();

  </script>
</polymer-element>

