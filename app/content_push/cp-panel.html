<link rel="import" href="../bower_components/core-toolbar/core-toolbar.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../bower_components/core-header-panel/core-header-panel.html">
<link rel="import" href="../bower_components/paper-menu-button/paper-menu-button.html">
<link rel="import" href="../bower_components/paper-item/paper-item.html">
<link rel="import" href="../bower_components/paper-progress/paper-progress.html">
<link rel="import" href="./cp-icons-svg.html">
<link rel="import" href="./cp-icons.html">
<link rel="import" href="./cp-aggregator.html">
<link rel="import" href="./cp-display.html">
<link rel="import" href="./cp-detail-article.html">
<link rel="import" href="./cp-detail-file.html">
<link rel="import" href="./cp-detail-image.html">
<link rel="import" href="./cp-swapper.html">
<link rel="import" href="./cp-sources-groups.html">
<link rel="import" href="./cp-sources-storage.html">

<polymer-element name="cp-panel"
                 on-newkeywordinfo="{{onNewKeywordInfo}}"
                 on-nlpstart="{{onNlpStart}}"
                 on-nlpstop="{{onNlpStop}}">
  <template>
    <style>
      :host {
        height: 100%;
      }

      #toolbar {
        display: flex;
        flex-direction: column;
        height: 64px;
        background-color: #B8578C;
        margin: 0;
        padding: 0;
        z-index: 500;
      }

      #toolbar::shadow #bottomBar {
        padding: 0;
      }

      #toolbartext {
        color: #FFFFFF;
        -webkit-user-select: none;
        font-size: 20px;
        line-height: 25px;
      }

      #toolbaraction {
        color: #FFFFFF;
        -webkit-user-select: none;
        margin-right: -8px;
        line-height: 24px;
      }

      #progress {
        width: 100%;
        margin: 60px 0 0 0;
        opacity: 0;
        transition: opacity 0.25 ease-out;
      }

      #progress.fadein {
        opacity: 1;
      }

      #progress.fadeout {
        opacity: 0;
      }

      #display {
        padding: 0;
        height: calc(100% - 64px);
        width: 100%;
        overflow: hidden;
        box-sizing: border-box;
      }

      cp-swapper {
        width: 100%;
        height: 100%;
      }

      [swapper-slide], [swapper-fix] {
        background-color: #fafafa;
      }

      #menu {
        padding: 0;
        margin-left: 8px;
        margin-right: 16px;
        line-height: 24px;
      }

      #menu::shadow core-icon, core-icon {
        color: white;
      }

      #menu::shadow core-dropdown, core-dropdown {
        left: 32px;
      }

      #menu paper-item {
        font-size: 14px;
      }

      #menu paper-item::shadow #icon {
        margin-right: 32px;
        margin-left: 4px;
      }

      #menu paper-item::shadow core-icon, #menu paper-item::shadow #label {
        color: rgba(0, 0, 0, 0.87);
      }

      [data-show="false"] {
        display: none;
      }

      /* highlight for filter selected in the menu */
      [data-selected-filter="true"]::shadow * {
        color: #C42B7F !important;
      }

      /* this is a bit hacky because we have to set the fill and
         stroke properties of the SVG for the CP icon, rather than
         just set its colour */
      [data-selected-filter="true"]::shadow .triangle {
        stroke: #C42B7F !important;
      }

      [data-selected-filter="true"]::shadow .filled-triangle {
        fill: #C42B7F !important;
      }
    </style>

    <cp-icons id="icons"></cp-icons>

    <cp-sources-storage id="storage"
                        on-newsources="{{onNewSources}}"
                        on-sourceenabled="{{onSourceEnabledOrCreated}}"
                        on-sourcecreated="{{onSourceEnabledOrCreated}}">
    </cp-sources-storage>

    <cp-swapper id="swapper">
      <div swapper-fix>
        <!-- the panel is made up of a header toolbar and the display -->
        <core-toolbar id="toolbar">
          <!-- items in this menu set the "types" part of the display filter -->
          <paper-menu-button id="menu" icon="menu" on-click="{{onMenuClick}}">
            <paper-item icon="cp-icons-svg:cp-icon"
                        label="Content Push"
                        data-type-filter="no-filter"
                        data-selected-filter="true">
            </paper-item>

            <template repeat="{{groupName in groupNames}}">
              <paper-item icon="{{$.icons[groupName]}}" label="{{groupName}}"
                          data-type-filter="{{groupName|lowercaseSingular}}">
              </paper-item>
            </template>

            <paper-item icon="{{$.icons.editSources}}" label="EDIT SOURCES"
                        id="itemEditSources">
            </paper-item>
          </paper-menu-button>

          <span id="toolbartext" flex>Content Push</span>

          <paper-icon-button id="toolbaraction" icon="close"
                             on-tap="{{closePanel}}">
          </paper-icon-button>

          <paper-progress id="progress" indeterminate class="bottom"></paper-progress>
        </core-toolbar>

        <cp-display id="display"
                    on-moreresults="{{onDisplayMoreResults}}"
                    on-mouse-over="{{onDisplayMouseover}}"
                    on-mouse-out="{{onDisplayMouseout}}"
                    on-mouse-down="{{showDetail}}"
                    on-slider-change="{{sliderChange}}">
        </cp-display>
      </div>

      <cp-detail-article id="detailArticle" on-back="{{closeDetail}}"
                         swapper-slide swap-id="detailarticle">
      </cp-detail-article>

      <cp-detail-image id="detailImage" on-back="{{closeDetail}}"
                       swapper-slide swap-id="detailimage">
      </cp-detail-image>

      <cp-detail-file id="detailFile" on-back="{{closeDetail}}"
                      swapper-slide swap-id="detailfile">
      </cp-detail-file>

      <cp-sources-groups id="groups"
                  on-back="{{closeGroups}}"
                  swapper-slide swap-id="groups">
      </cp-sources-groups>
    </cp-swapper>

    <cp-aggregator id="aggregator"
                   on-receivedresults="{{onReceivedResults}}"
                   on-searchfailed="{{onSearchFailed}}"
                   on-nopendingsearches="{{onNoPendingSearches}}">
    </cp-aggregator>
  </template>

  <script src="../bower_components/lodash/dist/lodash.js"></script>
  <script src="cp-array-utils.js"></script>

  <script>
    (function () {
      /* maximum number of keywords to consider each time NLP
         finishes parsing the current context */
      var MAX_KEYWORDS = 5;

      var KeywordSelector = function () {
        /* array of all keywords extracted from the document so far */
        this.keywords = [];

        /* array of keywords associated with the currently-visible part
           of the document */
        this.activeKeywords = [];

        /* "width" across the set of current active keywords; this
           decides which of the active keywords are returned as
           the "current" keywords  */
        this.width = 0.5;
      };

      /*
       * get the active keywords, filtered by the current "width"
       * TODO we're currently just return all the active keywords,
       * which are truncated at the point where they are set
       * in setActiveKeywords()
       */
      KeywordSelector.prototype.getCurrentKeywords = function () {
        return this.activeKeywords;
      };

      /* sets the active keywords; NB any keywords set
         here are also added to the array of all keywords in the document;
         returns an array of the keywords from the array <keywords>
         which were not in the existing active keywords array */
      KeywordSelector.prototype.setActiveKeywords = function (keywords) {
        var keywordsToUse = keywords.slice(0, MAX_KEYWORDS);
        var newKeywords = this.checkKeywordInfoChanged(keywordsToUse);
        this.keywords = this.keywords.concat(keywords);
        this.activeKeywords = keywordsToUse;
        return newKeywords;
      };

      KeywordSelector.prototype.setWidth = function (width) {
        this.width = width;
      };

      /* TODO fire an event when the current keywords changed rather
       * than having to manually test whether they have
       *
       * tests whether the current keywords have changed
       *
       * oldKeywords and newKeywords have this format:
       * [
       *   {
       *     text: "keyword text",
       *     score: 1.66,
       *     groupId: 10
       *   },
       *   ...
       * ]
       *
       * returns an array of new keywords in the same format as the input
       */
      KeywordSelector.prototype.checkKeywordInfoChanged = function (newKeywords) {
        var currentKeywords = this.getCurrentKeywords();

        /* no keywords yet, so definitely a change */
        if (newKeywords.length && !currentKeywords.length) {
          return newKeywords;
        } else {
          return ArrayUtils.diff(currentKeywords, newKeywords, function (elt1, elt2) {
            return elt1.text === elt2.text;
          });
        }
      };

      // private *static* functions and constants

      var setFilter = function (self) {
        console.log('CP-PANEL: setFilter()');
        var currentKeywords = self.keywordSelector.getCurrentKeywords();

        if (!currentKeywords.length) {
          console.log('CP-PANEL: cannot setFilter as no current keywords');
          return;
        }

        /* set filter on the display based on current keywordInfo,
           selected result types and enabled sources */
        self.$.display.setFilter({
          currentKeywords: currentKeywords,
          types: self.typeFilter,
          sources: self.$.storage.retrieveAllSources()
        });
      };

      /* perform search for keywords and add to the display */
      var search = function (self, keywords, groupName, sourceName) {
        self.$.display.searchesPending = true;
        self.$.display.wait();
        self.$.aggregator.aggregate(keywords, groupName, sourceName);
      };

      /* return the keywords from tileKeywords which also occur
         in the current keywords (according to the keywordSelector) */
      var getKeywordsToHighlight = function (self, tileKeywords) {
        var results = [];

        var currentKeywords = self.keywordSelector.getCurrentKeywords();

        for (var i = 0; i < tileKeywords.length; i++) {
          for (var j = 0; j < currentKeywords.length; j++) {
            if (tileKeywords[i].text === currentKeywords[j].text) {
              results.push(tileKeywords[i]);
              break;
            }
          }
        }

        return results;
      };

      Polymer({
        // functions and properties used in API and bindings
        created: function () {
          /* an array of types of result to show in the display,
             or empty array to have no filter set */
          this.typeFilter = [];

          this.keywordSelector = new KeywordSelector();
        },

        domReady: function () {
          this.onNewSources();
        },

        onNewSources: function () {
          this.groupNames = this.$.storage.getGroupNames();
          setFilter(this);
        },

        // called from content-push.html:trackAction() when splitter moves
        layout: function () {
          this.$.display.layout();
        },

        showDetail: function (e) {
          var tile = e.detail;
          if (tile.type === 'image') {
            this.$.detailImage.showTile(tile);
            this.$.swapper.slideIn('detailimage');
          } else if (tile.type === 'file') {
            this.$.detailFile.showTile(tile);
            this.$.swapper.slideIn('detailfile');
          } else if (tile.type === 'article') {
            this.$.detailArticle.showTile(tile);
            this.$.swapper.slideIn('detailarticle');
          }
        },

        closeDetail: function (e) {
          this.$.swapper.activeElt.close();
          this.$.swapper.slideOut();
          this.fire('mouseoutimage', e.target.highlights);
          e.target.highlights = null;
        },

        closeGroups: function () {
          this.$.swapper.slideOut('groups');
        },

        onMenuClick: function (e) {
          var elt = e.toElement;
          var typeFilter = elt.getAttribute('data-type-filter');

          if (typeFilter) {
            /* switch title bar text based on menu item selection */
            if (typeFilter === 'no-filter') {
              this.typeFilter = [];
              this.$.toolbartext.innerHTML = 'Content Push';
            } else {
              this.typeFilter = typeFilter.split(',');
              this.$.toolbartext.innerHTML = elt.label;
            }

            /* remove any highlight */
            var selected = this.$.menu.querySelector('[data-selected-filter="true"]');
            if (selected && selected !== elt) {
              selected.setAttribute('data-selected-filter', 'false');
            }

            /* highlight the selected filter */
            elt.setAttribute('data-selected-filter', 'true');

            setFilter(this);
          } else if (elt.id === 'itemEditSources') {
            /* open sources editor */
            this.$.swapper.slideIn('groups');
          }
        },

        /* keywordInfo event occurred on the document */
        onNewKeywordInfo: function (e) {
          console.log('CP-PANEL:onNewKeywordInfo', e.detail.keywordInfo);

          var candidateKeywords = e.detail.keywordInfo.keywords;
          var newKeywords = this.keywordSelector.setActiveKeywords(candidateKeywords);

          if (newKeywords.length > 0) {
            console.log('CP-PANEL:onNewKeywordInfo - newKeywords', newKeywords);

            /* we have new keywords, run a fresh search for them */
            this.$.display.reset();
            search(this, newKeywords);
          } else {
            /* just reset current keywords and filter (the new set
               of keywords is either the same as or a subset of the
               existing current keywords) */
            setFilter(this);
          }
        },

        /* NLP started processing new context, so fade in indeterminate progress */
        onNlpStart: function () {
          this.$.progress.classList.remove('fadeout');
          this.$.progress.classList.add('fadein');
        },

        /* NLP finished processing context, so fade out indeterminate progress */
        onNlpStop: function () {
          this.$.progress.classList.remove('fadein');
          this.$.progress.classList.add('fadeout');
        },

        /* search more using current keywordInfo */
        onDisplayMoreResults: function () {
          search(this, this.keywordSelector.getCurrentKeywords());
        },

        onDisplayMouseover: function (e) {
          var keywordsToHighlight = getKeywordsToHighlight(this, e.detail);
          this.fire('mouseoverimage', keywordsToHighlight);
        },

        onDisplayMouseout: function (e) {
          var openDetail = this.shadowRoot.querySelectorAll('#swapper > [data-open="true"]');
          var keywordsToUnhighlight = getKeywordsToHighlight(this, e.detail);
          if (openDetail.length === 0) {
            this.fire('mouseoutimage', keywordsToUnhighlight);
          } else {
            openDetail[0].highlights = keywordsToUnhighlight;
          }
        },

        /* the first result which loads successfully into a tile
           will turn off the waiting indicator on cp-display */
        onReceivedResults: function (e) {
          this.$.display.receiveResults(e.detail.results);
          setFilter(this);
        },

        onSearchFailed: function (e) {
          /* TODO notify user of search errors in UI */
          this.$.display.receiveResults([]);
          console.error(e.detail.error);
          console.error(e.detail.error.stack);
          setFilter(this);
        },

        /* if the aggregator has finished searching, ensure the
           waiting indicator on cp-display is off, even if no results
           were found */
        onNoPendingSearches: function () {
          console.log('CP-PANEL: got nopendingsearches');
          this.$.display.searchesPending = false;
          this.$.display.stopWaiting();
        },

        /* if there are no results for a source and it is added or enabled,
           run a search */
        onSourceEnabledOrCreated: function (e) {
          var groupName = e.detail.groupName;
          var sourceName = e.detail.sourceName;

          if (!this.$.display.hasResultForSourceName(sourceName)) {
            var currentKeywords = this.keywordSelector.getCurrentKeywords();
            search(this, currentKeywords, groupName, sourceName);
          }
        },

        closePanel: function () {
          this.fire('close-panel');
        },

        sliderChange: function () {
          setFilter(this);
        },

        lowercaseSingular: function (value) {
          return value.toLowerCase().replace(/s$/, '');
        }
      }); // Polymer()
    })();
  </script>
</polymer-element>
