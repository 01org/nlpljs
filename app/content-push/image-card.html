<link rel="import" href="./image-item.html">

<polymer-element name="image-card">
  <template>
    <style>
      :host {
        display: block;
      }

      #container {
        position: relative;
      }

      image-item {
        position: absolute;
        transition-property: top, left, opacity;
        transition-duration: 0.25s, 0.25s, 1s;
        transition-timing-function: ease-out, ease-out, ease-out;
      }

      /*
      when an image-item displays inside an image-card, a margin
      appears to be added below the meta paragraph; I couldn't track
      this down, so this work-around removes that margin for
      image-items only in the context of an image-card
      */
      image-item::shadow #meta {
        margin: 0 0 3px 0;
      }
    </style>

    <div id="container"></div>
  </template>

  <script src="../bower_components/lodash/dist/lodash.js"></script>
  <script src="image-card-frame-chooser.js"></script>
  <script src="image-card-layout-generator.js"></script>

  <script>
    (function () {
      var NARROW_NUM_COLS = 4;
      var WIDE_NUM_COLS = 8;

      // when gallery >= this width, switch to WIDE_NUM_COLS
      var WIDE_BREAKPOINT = 456;

      /*
      length of the side of a row/column for the purpose of
      choosing a frame
      */
      var FRAME_CELL_SIDE = 54;

      /*
      timeout (in ms) before treating an image load as failed
      */
      var TIMEOUT = 5000;

      Polymer({
        created: function () {
          this.frameChooser = new FrameChooser(FRAME_CELL_SIDE, FRAME_CELL_SIDE);
          this.layoutGenerator = new LayoutGenerator();
          this.numColumns = NARROW_NUM_COLS;

          // cached height and width, to reduce the number of events fired
          this.lastMeasuredHeight = 0;
          this.lastMeasuredWidth = 0;

          // count of the number of images currently loading
          this.countChildrenLoading = 0;
        },

        // set number of columns based on the gallery width
        setLayoutParams: function () {
          var width = this.$.container.offsetWidth;

          if (width >= WIDE_BREAKPOINT) {
            this.numColumns = WIDE_NUM_COLS;
          }
          else {
            this.numColumns = NARROW_NUM_COLS;
          }
        },

        domReady: function () {
          this.setLayoutParams();
        },

        /**
         * Return all child image-item elements
         */
        getChildren: function () {
          return this.$.container.querySelectorAll('image-item');
        },

        /**
        * Convenience method to append an image search result to the
        * gallery; creates a cp-image element for the image object added.
        *
        * @param Object image Representation of image to add; has the
        * format:
        * {
        *   src: "<url of image>",
        *   keyphrase: {
        *     text: "<keyphrase text>",
        *     groupId: "<keyphrase group ID>"
        *   }
        * }
        *
        * The keyphrase groupId is assigned by the NLP engine and
        * enables the Highlighter to identify the correct ranges
        * in the Context when highlights are toggled.
        *
        * TODO If the URL already exists on an image-item inside the card,
        * its keyphrases are updated, rather than a new image being added.
        *
        * @fires childrenchanged Event data:
        * {
        *   added: <reference to the child element which was added>,
        *   numChildren: <total number of children>,
        *   parent: <reference to this image-card>
        * }
        */
        appendImage: function (image) {
          var self = this;

          var keyphrase = '';
          if (image.keyphrase) {
            keyphrase = image.keyphrase.text;
          }

          var elt = document.createElement('image-item');

          this.countChildrenLoading++;
          this.fireChildrenLoading();

          // image loaded successfully
          elt.addEventListener('load', function () {
            self.frameImage(elt);
            self.$.container.appendChild(elt);
            self.layout();

            self.fire('childrenchanged', {
              added: elt,
              numChildren: self.getChildren().length,
              parent: self
            });

            self.countChildrenLoading--;
            self.fireChildrenLoading();
            elt.counted = true;
          });

          /*
          image fails to load, we still need to remove it from
          the count of loading images
          */
          elt.addEventListener('error', function (e) {
            self.countChildrenLoading--;
            self.fireChildrenLoading();
            elt.counted = true;
          });

          /*
          set a timeout so that if the image still hasn't loaded
          (e.g. the server is down) we can clear the loading count
          */
          setTimeout(function () {
            if (!elt.counted) {
              self.countChildrenLoading--;
              self.fireChildrenLoading();
              elt.counted = true;
            }
          }, TIMEOUT);

          elt.$.container.addEventListener('mouseover', function () {
            self.fire('mouse-over', { keyword: keyphrase });
          });

          elt.$.container.addEventListener('mouseout', function () {
            self.fire('mouse-out', { keyword: keyphrase });
          });

          elt.src = image.src;
          elt.setAttribute('keyword', keyphrase);
        },

        /**
         * Add the appropriate frame to the image-item img.
         *
         * @param DOMElement img image-item element
         */
        frameImage: function (img) {
          var frame = this.frameChooser.choose(img);
          img.setAttribute('data-frame', frame.name);
          img.setAttribute('data-columns', frame.columns);
          img.setAttribute('data-rows', frame.rows);
        },

        /**
         * Apply layout to image-items.
         */
        layout: function () {
          this.setLayoutParams();

          var cellSide = this.$.container.offsetWidth / this.numColumns;
          var imageItems = this.getChildren();

          // convert imageItems into shapes
          var shapes = [];

          for (var i = 0; i < imageItems.length; i++) {
            var imageItem = imageItems[i];

            shapes.push({
              elt: imageItem,
              width: parseInt(imageItem.getAttribute('data-columns'), 10),
              height: parseInt(imageItem.getAttribute('data-rows'), 10)
            });
          }

          var layout = this.layoutGenerator.generate(shapes, this.numColumns);

          var shape, position, elt, firstCol, width, x,
              firstRow, height, y;

          _.each(layout.placements, function (placement) {
            shape = placement.shape;
            position = placement.position;

            width = position.columns.length * cellSide;
            firstCol = _.first(position.columns);
            x = firstCol * cellSide;

            height = position.rows.length * cellSide;
            firstRow = _.first(position.rows);
            y = firstRow * cellSide;

            shape.elt.style.left = x + 'px';
            shape.elt.style.top = y + 'px';
            shape.elt.style.width = width + 'px'
            shape.elt.style.height = height + 'px';
          });

          // set the container height
          var height = layout.grid.length * cellSide;
          this.$.container.style.height = height + 'px';

          /*
          fire an event to notify listeners that this element's height
          has changed; this is required for infini-scroll to work
          */
          var width = this.offsetWidth;
          var height = this.offsetHeight;

          if (this.lastMeasuredWidth !== width ||
              this.lastMeasuredHeight !== height) {
            this.lastMeasuredWidth = width;
            this.lastMeasuredHeight = height;

            this.fire('resize', {
              width: width,
              height: height
            });
          }
        },

        /**
         * Remove all image-item elements from the card
         */
        clear: function () {
          var imageItems = this.getChildren();
          for (var i = 0; i < imageItems.length; i++) {
            imageItems[i].parentNode.removeChild(imageItems[i]);
            imageItems[i] = null;
          }

          /*
          reset the height of the container (cheap operation
          as there are no children at this point)
          */
          this.layout();

          this.fire('childrenchanged', {
            cleared: true,
            numChildren: 0,
            parent: this
          });
        },

        /**
         * Fire a "childrenloading" event with a count of the number
         * of images which are currently loading.
         *
         * @fires childrenloading Event data: count of the number of
         * images which are currently loading into the component.
         */
        fireChildrenLoading: function () {
          this.fire('childrenloading', this.countChildrenLoading);
        }
      })
    })();
  </script>
</polymer-element>
