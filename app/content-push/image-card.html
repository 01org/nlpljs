<link rel="import" href="./image-item.html">

<polymer-element name="image-card">
  <template>
    <style>
      :host {
        display: block;
      }

      #container {
        position: relative;
      }

      image-item {
        position: absolute;
        transition-property: top, left, opacity;
        transition-duration: 0.25s, 0.25s, 1s;
        transition-timing-function: ease-out, ease-out, ease-out;
      }

      /*
      when an image-item displays inside an image-card, a margin
      appears to be added below the meta paragraph; I couldn't track
      this down, so this work-around removes that margin for
      image-items only in the context of an image-card
      */
      image-item::shadow #meta {
        margin: 0 0 3px 0;
      }
    </style>

    <div id="container"></div>
  </template>

  <script src="../bower_components/lodash/dist/lodash.js"></script>
  <script src="image-card-frame-chooser.js"></script>
  <script src="image-card-layout-generator.js"></script>

  <script>
    (function () {
      var NARROW_NUM_COLS = 4;
      var WIDE_NUM_COLS = 8;

      // when gallery >= this width, switch to WIDE_NUM_COLS
      var WIDE_BREAKPOINT = 456;

      // length of the side of a row/column for the purpose of
      // choosing a frame
      var FRAME_CELL_SIDE = 54;

      Polymer({
        created: function () {
          this.frameChooser = new FrameChooser(FRAME_CELL_SIDE, FRAME_CELL_SIDE);
          this.layoutGenerator = new LayoutGenerator();
          this.numColumns = NARROW_NUM_COLS;

          // cached height and width, to reduce the number of events fired
          this.lastMeasuredHeight = 0;
          this.lastMeasuredWidth = 0;
        },

        // set number of columns based on the gallery width
        setLayoutParams: function () {
          var width = this.$.container.offsetWidth;

          if (width >= WIDE_BREAKPOINT) {
            this.numColumns = WIDE_NUM_COLS;
          }
          else {
            this.numColumns = NARROW_NUM_COLS;
          }
        },

        domReady: function () {
          this.setLayoutParams();
        },

        /**
        * Convenience method to append an image search result to the
        * gallery; creates a cp-image element for the image object added.
        *
        * @param Object image Representation of image to add; has the
        * format:
        * {
        *   src: <url of image>
        * }
        */
        appendImage: function (image, keyword) {
          var self = this;

          var elt = document.createElement('image-item');

          elt.addEventListener('load', function () {
            self.frameImage(elt);
            self.$.container.appendChild(elt);
            self.layout();
          });

          elt.$.container.addEventListener('mouseover', function () {
            self.fire('mouse-over', { keyword: elt.keyword });
          });

          elt.$.container.addEventListener('mouseout', function () {
            self.fire('mouse-out', { keyword: elt.keyword });
          });

          elt.src = image.src;
          elt.keyword = keyword;
        },

        /**
         * Add the appropriate frame to the image-item img.
         *
         * @param DOMElement img image-item element
         */
        frameImage: function (img) {
          var frame = this.frameChooser.choose(img);
          img.setAttribute('data-frame', frame.name);
          img.setAttribute('data-columns', frame.columns);
          img.setAttribute('data-rows', frame.rows);
        },

        /**
         * Apply layout to image-items.
         */
        layout: function () {
          this.setLayoutParams();

          var cellSide = this.$.container.offsetWidth / this.numColumns;
          var imageItems = this.$.container.querySelectorAll('image-item');

          // convert imageItems into shapes
          var shapes = [];

          for (var i = 0; i < imageItems.length; i++) {
            var imageItem = imageItems[i];

            shapes.push({
              elt: imageItem,
              width: parseInt(imageItem.getAttribute('data-columns'), 10),
              height: parseInt(imageItem.getAttribute('data-rows'), 10)
            });
          }

          var layout = this.layoutGenerator.generate(shapes, this.numColumns);

          var shape, position, elt, firstCol, width, x,
              firstRow, height, y;

          _.each(layout.placements, function (placement) {
            shape = placement.shape;
            position = placement.position;

            width = position.columns.length * cellSide;
            firstCol = _.first(position.columns);
            x = firstCol * cellSide;

            height = position.rows.length * cellSide;
            firstRow = _.first(position.rows);
            y = firstRow * cellSide;

            shape.elt.style.left = x + 'px';
            shape.elt.style.top = y + 'px';
            shape.elt.style.width = width + 'px'
            shape.elt.style.height = height + 'px';
          });

          // set the container height
          var height = layout.grid.length * cellSide;
          this.$.container.style.height = height + 'px';

          /*
          fire an event to notify listeners that this element's height
          has changed; this is required for infini-scroll to work
          */
          var width = this.offsetWidth;
          var height = this.offsetHeight;

          if (this.lastMeasuredWidth !== width ||
              this.lastMeasuredHeight !== height) {
            this.lastMeasuredWidth = width;
            this.lastMeasuredHeight = height;
            this.fire('resize', { width: width, height: height });
          }
        }
      })
    })();
  </script>
</polymer-element>
