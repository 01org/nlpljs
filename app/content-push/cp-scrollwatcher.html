<polymer-element name="cp-scrollwatcher">
  <template></template>
  <script>
    (function () {
      var scrollableNode;
      var targetNodes = [];
      var targetAttributes = [];
      var timeout = 500;
      var scrollTimer;

      var isNodeVisible = function (node) {
        var boundingRectangle = node.getBoundingClientRect();
        var parentBoundingRectangle;

        var nodeStyle = document.defaultView.getComputedStyle(node, null);

        if ('0' === nodeStyle['opacity'] || 'none' === nodeStyle['display'] ||
            'hidden' === nodeStyle['visiblity'])
          return false;

        if (typeof scrollableNode !== 'undefined') {
          parentBoundingRectangle = scrollableNode.getBoundingClientRect();

          if (boundingRectangle.bottom > parentBoundingRectangle.bottom ||
              boundingRectangle.right > parentBoundingRectangle.right ||
              boundingRectangle.left < parentBoundingRectangle.left ||
              boundingRectangle.top < parentBoundingRectangle.top)
            return false;
        }

        if (boundingRectangle.bottom > window.innerHeight ||
            boundingRectangle.right > window.innerWidth ||
            boundingRectangle.left < 0 ||
            boundingRectangle.top < 0)
          return false;

        return true;
      };

      Polymer({
        setScrollableNode: function (node) {
          scrollableNode = node;
        },
        addOnScrollListener: function (listener, data) {
          var onScroll = function () {
            clearTimeout(scrollTimer);
            scrollTimer = setTimeout(function () {
              var visibleNodes = [];
              var visibleId = '';

              if (typeof targetNodes !== 'undefined') {
                for (var i = 0; i < targetNodes.length; i++) {
                  if (isNodeVisible(targetNodes[i])) {
                    visibleNodes[visibleNodes.length] = targetNodes[i];
                    for (var j = 0; j < targetAttributes.length; j++) {
                      if (targetNodes[i].hasAttribute(targetAttributes[j])) {
                        visibleId +=
                          targetNodes[i].getAttribute(targetAttributes[j]);
                        if (i < targetNodes.length - 1)
                          visibleId += ' ';
                      }
                    }
                  }
                }
              }

              listener(visibleNodes, visibleId, data);
            }, timeout);
          };

          if (typeof scrollableNode !== 'undefined')
            scrollableNode.addEventListener('scroll', onScroll, false);

          window.addEventListener('DOMContentLoaded', onScroll, false); 
          window.addEventListener('load', onScroll, false); 
          window.addEventListener('scroll', onScroll, false); 
          window.addEventListener('resize', onScroll, false);
        },
        performImmediateVisibilityCheck: function (callback, data) {
          var visibleNodes = [];
          var visibleId = '';

          if (typeof targetNodes !== 'undefined') {
            for (var i = 0; i < targetNodes.length; i++) {
              if (isNodeVisible(targetNodes[i])) {
                visibleNodes[visibleNodes.length] = targetNodes[i];
                for (var j = 0; j < targetAttributes.length; j++) {
                  if (targetNodes[i].hasAttribute(targetAttributes[j])) {
                    visibleId +=
                     targetNodes[i].getAttribute(targetAttributes[j]);
                    if (i < targetNodes.length - 1)
                      visibleId += ' ';
                  }
                }
              }
            }
          }

          callback(visibleNodes, visibleId, data);
        },
        addTargetAttribute: function (targetAttribute) {
          targetAttributes[targetAttributes.length] = targetAttribute;
        },
        addTargetNode: function (targetNode) {
          targetNodes[targetNodes.length] = targetNode;
        },
        removeTargetAttribute: function (targetAttribute) {
          var index = targetAttributes.indexOf(targetAttribute);
          targetAttributes.splice(index, 1);
        },
        removeTargetNode: function (targetNode) {
          var index = targetNodes.indexOf(targetNode);
          targetNodes.splice(index, 1);
        },
        setScrollTimeout: function (scrollTimeout) {
          timeout = scrollTimeout;
        }
      });
    })();
  </script>
</polymer-element>
