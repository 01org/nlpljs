<!--
wraps a single element in a scrollable area;
when the wrapped element has 3 or fewer children, a button
is shown which triggers a "replacecontent" event when pressed

if the wrapped element is the same height or taller than the scroller,
a vertical scrollbar is added; when the scroll reaches nearly the
end, a "morecontent" event is fired

note that if multiple elements are inside an infini-scroll, only the
first one is used to determine whether the button is visible and
to set the y scroll boundary

for the "no content" visibility to be toggled on/off, the wrapped
element should also fire a "childrenchanged" event when new child elements
are added to it (NB it would be nice to use MutationObservers for
this, but these don't work inside the Shadow DOM, which is where
the child elements we're interested in are being added)
-->
<link rel="import" href="../bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../bower_components/paper-spinner/paper-spinner.html">

<!-- this is needed for the icon on the "more" button -->
<link rel="import" href="../bower_components/core-icons/core-icons.html">

<polymer-element name="infini-scroll" attributes="showButton scrollGap">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
        overflow-x: hidden;
        overflow-y: scroll;
      }

      #nocontent {
        text-align: center;
        width: 60%;
        margin-left: 15%;
      }

      #loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin-top: 1em;
      }

      /* fill the whole panel when there is no content */
      #fullPageLoading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 100%;
        z-index: 1000;
      }

      #welcome, #more {
        text-align: center;
        margin: 3em 0 0 0;
        width: 60%;
        margin-left: 15%;
        content-sizing: border-box;
      }

      #more {
        border-top: thin solid gray;
      }

      #morebutton {
        background-color: #01bcd4;
        color: gray;
      }

      [data-show="false"] {
        display: none !important;
      }
    </style>

    <!-- never searched -->
    <div id="welcome" data-show="true">
      Your related content should arrive shortly.
    </div>

    <!-- wrapped content which will become scrollable -->
    <content id="content" select="*" on-resize="{{onContentResize}}"
             on-childrenchanged="{{onChildrenChanged}}"
             on-childrenloading="{{onChildrenLoading}}">
    </content>

    <!-- full page loader for a fresh search -->
    <div id="fullPageLoading" data-show="false">
      <paper-spinner active></paper-spinner>
    </div>

    <!-- loader at the end of existing results -->
    <div id="loading" data-show="false">
      <paper-spinner active></paper-spinner>
    </div>

    <!-- "widen the search" button -->
    <div id="more" data-show="false">
      <p>Widen the search</p>
      <paper-fab id="morebutton" mini icon="add"
                 raisedButton="true" on-click="{{fireReplaceContent}}">
      </paper-fab>
    </div>

    <!-- no content available -->
    <div id="nocontent" data-show="false">
      Sorry, we couldn't find anything
    </div>
  </template>

  <script>
    (function () {
      /*
      default number of pixels between the scroll position and the
      end of the container when the "morecontent" event triggers,
      signifying that the container should have more content added to it
      */
      var DEFAULT_SCROLL_GAP = 100;

      /*
      if there are <= this number of results in the wrapped content
      element, show the "widen the search" button
      */
      var FEW_RESULTS = 3;

      Polymer({
        created: function () {
          // the number of children the wrapped content element has
          this.numChildren = 0;

          this.loading = false;
        },

        domReady: function () {
          // event handler for scroll events on the container
          this.addEventListener('scroll', this.onScroll.bind(this));
        },

        onScroll: function () {
          var gap = this.scrollGap || DEFAULT_SCROLL_GAP;
          if (this.scrollTop + this.offsetHeight >= this.scrollHeight - gap) {
            this.fireMoreContent();
          }
        },

        /*
        called when a child is added or removed from the wrapped content
        element
        */
        onChildrenChanged: function (e) {
          this.numChildren = e.detail.numChildren;
          this.setState();
        },

        /*
        called when the number of images being loaded into the wrapped
        content element changes

        e is an event whose detail is a count of the number of children
        loading into the wrapped element
        */
        onChildrenLoading: function (e) {
          if (e.detail > 0) {
            this.loading = true;
          } else {
            this.loading = false;
          }
          this.setState();
        },

        /*
        fire a "morecontent" event, signifying either that the end of
        the scroll was reached; it's up to listeners to decide what to do
        with this (e.g. append more content into the wrapped element)
        */
        fireMoreContent: function () {
          this.fire('morecontent');
        },

        /*
        fire a "replacecontent" event, signifying that the content of
        the wrapped element should be replaced
        */
        fireReplaceContent: function () {
          this.fire('replacecontent');
        },

        setState: function () {
          this.$.welcome.setAttribute('data-show', 'false');

          if (this.loading) {
            if (this.numChildren === 0) {
              // full page load
              this.$.nocontent.setAttribute('data-show', 'false');
              this.$.more.setAttribute('data-show', 'false');
              this.$.fullPageLoading.setAttribute('data-show', 'true');
              this.$.loading.setAttribute('data-show', 'false');
            } else {
              // loader at end of page, results still show
              this.$.fullPageLoading.setAttribute('data-show', 'false');
              this.$.loading.setAttribute('data-show', 'true');
            }
          } else {
            this.$.fullPageLoading.setAttribute('data-show', 'false');
            this.$.loading.setAttribute('data-show', 'false');

            if (this.numChildren === 0) {
              this.$.nocontent.setAttribute('data-show', 'true');
              this.$.more.setAttribute('data-show', 'true');
            } else if (this.numChildren < FEW_RESULTS) {
              this.$.nocontent.setAttribute('data-show', 'false');
              this.$.more.setAttribute('data-show', 'true');
            } else {
              this.$.nocontent.setAttribute('data-show', 'false');
              this.$.more.setAttribute('data-show', 'false');
            }
          }
        }
      });
    })();
  </script>
</polymer-element>
