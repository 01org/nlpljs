<link rel="import" href="./image-item.html">

<polymer-element name="cp-layout">
  <template>
    <style>
      :host {
        display: block;
      }

      #container {
        position: relative;
      }

      cp-tile-image {
        position: absolute;
        transition-property: top, left, opacity;
        transition-duration: 0.25s, 0.25s, 1s;
        transition-timing-function: ease-out, ease-out, ease-out;
      }

      /*
      when an cp-tile-image displays inside this element, a margin
      appears to be added below the meta paragraph; I couldn't track
      this down, so this work-around removes that margin for
      cp-tile-images only in the context of a this element
      */
      cp-tile-image::shadow #meta {
        margin: 0 0 3px 0;
      }
    </style>

    <div id="container"></div>
  </template>

  <script src="../bower_components/lodash/dist/lodash.js"></script>
  <script src="cp-layout-frame-chooser.js"></script>
  <script src="cp-layout-generator.js"></script>

  <script>
    (function () {
      var NARROW_NUM_COLS = 4;
      var WIDE_NUM_COLS = 8;

      // when gallery >= this width, switch to WIDE_NUM_COLS
      var WIDE_BREAKPOINT = 456;

      /*
      length of the side of a row/column for the purpose of
      choosing a frame
      */
      var FRAME_CELL_SIDE = 54;

      /*
      base URL for Google's image resizer (undocumented);
      see http://carlo.zottmann.org/2013/04/14/google-image-resizer/
      */
      var RESIZER_BASE_URL = 'https://images1-focus-opensocial.googleusercontent.com/gadgets/proxy';

      var makeImageLoadHandler = function (layout, elt) {
        return function () {
          layout.frameImage(elt);
          layout.$.container.appendChild(elt);
          layout.layout();

          layout.fire('childrenchanged', {
            added: elt,
            numChildren: layout.getChildren().length,
            parent: layout
          });

          layout.countChildrenLoading--;
          layout.fireChildrenLoading();
          elt.counted = true;
        }
      };

      var makeImageErrorHandler = function (layout, elt) {
        return function () {
          layout.countChildrenLoading--;
          layout.fireChildrenLoading();
          elt.counted = true;
        }
      };

      var makeImageTimeoutHandler = function (layout, elt) {
        return function () {
          if (!elt.counted) {
            layout.countChildrenLoading--;
            layout.fireChildrenLoading();
            elt.counted = true;
          }
        };
      };

      var makeImageMouseoverHandler = function (layout, image) {
        return function () {
          layout.fire('mouse-over', image.keyphrase)
        };
      };

      var makeImageMouseoutHandler = function (layout, image) {
        return function () {
          layout.fire('mouse-out', image.keyphrase);
        };
      };

      Polymer({
        created: function () {
          this.frameChooser = new FrameChooser(FRAME_CELL_SIDE, FRAME_CELL_SIDE);
          this.layoutGenerator = new LayoutGenerator();
          this.numColumns = NARROW_NUM_COLS;

          // cached height and width, to reduce the number of events fired
          this.lastMeasuredHeight = 0;
          this.lastMeasuredWidth = 0;

          // count of the number of children currently loading
          this.childrenLoading = 0;
        },

        // set number of columns based on the gallery width
        setLayoutParams: function () {
          var width = this.$.container.offsetWidth;

          if (width >= WIDE_BREAKPOINT) {
            this.numColumns = WIDE_NUM_COLS;
          }
          else {
            this.numColumns = NARROW_NUM_COLS;
          }
        },

        domReady: function () {
          this.setLayoutParams();
        },

        /**
         * Return all child cp-tile-image elements
         */
        getChildren: function () {
          return this.$.container.querySelectorAll('cp-tile-image');
        },

        /**
        * Convenience method to append an image search result to the
        * gallery; creates a cp-image element for the image object added.
        *
        * @param Object image Representation of image to add; has the
        * format:
        * {
        *   src: "<url of image>",
        *   keyphrase: {
        *     text: "<keyphrase text>",
        *     groupId: "<keyphrase group ID>"
        *   }
        * }
        *
        * The keyphrase groupId is assigned by the NLP engine and
        * enables the Highlighter to identify the correct ranges
        * in the Context when highlights are toggled.
        *
        * TODO If the URL already exists on an cp-tile-image inside the card,
        * its keyphrases are updated, rather than a new image being added.
        *
        * @fires childrenchanged Event data:
        * {
        *   added: <reference to the child element which was added>,
        *   numChildren: <total number of children>,
        *   parent: <reference to this parent element>
        * }
        */
        appendImage: function (image) {
          var self = this;

          // for passing to Google's image resizer
          var resizeUrl;

          var keyphrase = '';
          if (image.keyphrase) {
            keyphrase = image.keyphrase.text;
          }

          var elt = document.createElement('cp-tile-image');

          this.childrenLoading++;
          this.fireLoadEvent();

          // image loaded successfully (or not)
          elt.addEventListener('done', function () {
            // loaded is false if the image failed to load
            if (elt.loaded) {
              self.frameTile(elt);
              self.$.container.appendChild(elt);
              self.layout();
            } else {
              elt = null;
            }

            self.childrenLoading--;
            self.fireLoadEvent();
          });

          elt.addEventListener('mouseover', function () {
            self.fire('mouse-over', image.keyphrase)
          });

          elt.addEventListener('mouseout', function () {
            self.fire('mouse-out', image.keyphrase);
          });

          // dynamically resize using Google's image resizer
          // TODO figure out a long term solution for this
          resizeUrl = RESIZER_BASE_URL +
                      '?container=focus&' +
                      'refresh=' + (60 * 60) + '&' + // cache for one hour
                      'resize_w=600&' + // set max image width to 600px
                      'url=' + encodeURIComponent(image.src);

          elt.src = resizeUrl;
          elt.keyword = image.keyphrase;
        },

        /**
         * Add the appropriate frame to the cp-tile-image img.
         *
         * @param DOMElement tile cp-tile* element
         */
        frameTile: function (tile) {
          var frame = this.frameChooser.choose(tile);
          tile.setAttribute('data-frame', frame.name);
          tile.setAttribute('data-columns', frame.columns);
          tile.setAttribute('data-rows', frame.rows);
        },

        /**
         * Apply layout to cp-tile-images.
         */
        layout: function () {
          this.setLayoutParams();

          var cellSide = this.$.container.offsetWidth / this.numColumns;
          var imageItems = this.getChildren();

          // convert imageItems into shapes
          var shapes = [];

          for (var i = 0; i < imageItems.length; i++) {
            var imageItem = imageItems[i];

            shapes.push({
              elt: imageItem,
              width: parseInt(imageItem.getAttribute('data-columns'), 10),
              height: parseInt(imageItem.getAttribute('data-rows'), 10)
            });
          }

          var layout = this.layoutGenerator.generate(shapes, this.numColumns);

          var shape, position, elt, firstCol, width, x,
              firstRow, height, y;

          _.each(layout.placements, function (placement) {
            shape = placement.shape;
            position = placement.position;

            width = position.columns.length * cellSide;
            firstCol = _.first(position.columns);
            x = firstCol * cellSide;

            height = position.rows.length * cellSide;
            firstRow = _.first(position.rows);
            y = firstRow * cellSide;

            shape.elt.style.left = x + 'px';
            shape.elt.style.top = y + 'px';
            shape.elt.style.width = width + 'px'
            shape.elt.style.height = height + 'px';
          });

          // set the container height
          var height = layout.grid.length * cellSide;
          this.$.container.style.height = height + 'px';

          /*
          fire an event to notify listeners that this element's height
          has changed; this is required for infini-scroll to work
          */
          var width = this.offsetWidth;
          var height = this.offsetHeight;

          if (this.lastMeasuredWidth !== width ||
              this.lastMeasuredHeight !== height) {
            this.lastMeasuredWidth = width;
            this.lastMeasuredHeight = height;

            this.fire('resize', {
              width: width,
              height: height
            });
          }
        },

        /**
         * Fire a "loading" or "loaddone" event, depending on the
         * number of children pending.
         */
        fireLoadEvent: function () {
          if (this.childrenLoading > 0) {
            this.fire('loading');
          } else {
            this.fire('loaddone');
          }
        }
      })
    })();
  </script>
</polymer-element>
