/**
 * cp-document
 */

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel='import' href='./cp-scrollwatcher.html'>
<link rel='import' href='./cp-keyword-highlighter.html'>

<polymer-element
  name='cp-document'
  on-mouseoverimage='{{onMouseOverImage}}'
  on-mouseoutimage='{{onMouseOutImage}}'
  attributes='iframeurl'>
  <template>
    <style>
      :host {
        position: relative;
      }

      #iframe {
        position: absolute;
        display: block;
        background-color: #f0f0f0;
        height: 100%;
        width: 100%;
        border: none;
      }

      #iframe.nopointerevents {
        pointer-events: none;
      };
    </style>
    <iframe id="iframe"></iframe>
    <cp-keyword-highlighter id='highlighter'></cp-keyword-highlighter>
    <cp-scrollwatcher id='scrollwatcher'></cp-scrollwatcher>
  </template>
  <script>
    (function cpDocument () {
      // private *static* functions and constants
      var LINE_CLASS = 'kix-lineview';        /* Handle to the current Page */
      var LINE_SELECTOR = '.kix-lineview';
      var SCROLLING_ELEMENT_SELECTOR = '.kix-appview-editor';

      var contextIds = [];

      /**
       * find ancestor of node that has className
       * for finding the ancestor with .kix-lineview of whatever line has changed
       */
      var findAncestor = function (node,className) {
        var retVal=null;

        var thisNode=node;
        var cssSelectorNotFound=true;

        while (cssSelectorNotFound && thisNode && thisNode.nodeName!="BODY") {
          cssSelectorNotFound=!thisNode.classList.contains(className);
          if (cssSelectorNotFound) {
            // move into parent node
            thisNode=thisNode.parentNode;
          } else {
            // finished
            retVal=thisNode;
          }
        }

        return retVal;
      };

      var observeDocumentChanges = function (self) {
        var observer = new MutationObserver(function (mutations,observerInstance) {
          for (var i = 0; i < mutations.length; i++) {
            var mutation = mutations[i];
            var newNodes = mutation.addedNodes;
            var removedNodes = mutation.removedNodes;

            if (removedNodes !== null) {
              for (var j = 0; j < removedNodes.length; j++) {
                var thisNode = removedNodes[j];
                if (thisNode) {
                  if (typeof thisNode.classList !== 'undefined' &&
                    thisNode.classList.contains(LINE_CLASS)) {
                    console.log('MO:removed line');
                  }
                }
              }
            }

            if (newNodes !== null) {
              for (var j = 0; j < newNodes.length; j++) {
                var thisNode = newNodes[j];
                if (thisNode) {
                  if (thisNode.nodeName === 'SPAN') {
                    if (findAncestor(thisNode, LINE_CLASS) !== null)
                      console.log('MO:editing line');
                  }
                  else if (typeof thisNode.classList !== 'undefined' &&
                    thisNode.classList.contains(LINE_CLASS)) {
                    if (thisNode.getAttribute('cp_line_id') === null) {
                      var lineIdAtt = document.createAttribute('cp_line_id');

                      console.log('MO:new line');

                      lineIdAtt.value = self.numLines;
                      thisNode.setAttributeNode(lineIdAtt);

                      self.$.scrollwatcher.addTargetNode(thisNode);
                      self.numLines++;
                    }
                  }
                }
              }
            }
          }
        });

        // Configuration of the observer:
        var config = {
          attributes: false,
          childList: true,
          subtree: true,
          characterData: false
        };

        // Pass in the target node, as well as the observer options
        observer.observe(self.$.iframe.contentDocument, config);
      };

      var handleIframeLoad = function (self){
        var lines =
          self.$.iframe.contentDocument.querySelectorAll(LINE_SELECTOR);

        self.editor =
          self.$.iframe.contentDocument.querySelector(SCROLLING_ELEMENT_SELECTOR);

        self.$.highlighter.targetElement = self.$.iframe.contentDocument;

        self.$.scrollwatcher.setScrollableNode(self.editor);
        self.$.scrollwatcher.addOnScrollListener(scrollStop, self);

        for (var i = 0; i < lines.length; i++) {
          addIdToLine(lines[i], self.numLines);
          self.numLines++;

          self.$.scrollwatcher.addTargetNode(lines[i]);
        }

        self.$.scrollwatcher.addTargetAttribute('cp_line_id');
        self.$.scrollwatcher.performImmediateVisibilityCheck(scrollStop, self);

        observeDocumentChanges(self);
      };

      var scrollStop = function (context, contextId, self) {
        getContext(self, contextId, context);
      };

      var addIdToLine = function (line, value) {
        var lineIdAtt = document.createAttribute('cp_line_id');

        lineIdAtt.value = value;
        line.setAttributeNode(lineIdAtt);
      };

      var getContext = function (self, contextId, context) {
        if (contextIds.indexOf(contextId) !== -1) {
          self.fire('getkeywords', { contextId: contextId });
          return;
        }

        self.fire('resetextractor', null);

        for (var i = 0; i < context.length; i++) {
          var lineId;

          lineId = context[i].getAttribute('cp_line_id');

          self.fire('lineadd',
            {
              contextId: contextId,
              lineId: lineId,
              text: context[i].innerText
            }
          );
        }

        contextIds[contextIds.length] = contextId;

        self.fire('getkeywords', { contextId: contextId });
      };

      /**
       * Add an image card (gallery) for the current page;
       * if the image card exists for this page already, do not
       * add the element, but just set the keywordInfo.
       */
      var setKeywordInfo = function (self, keywordInfo) {
        self.keywordInfo = keywordInfo;
        self.fire('newkeywordinfo',{keywordInfo: keywordInfo});

        self.$.highlighter.clear();
        self.$.highlighter.prepare(keywordInfo.ranges);

      };

      Polymer({
        // functions and properties used in API and bindings
        // life cycle handlers
        created: function () {
          this.iframeurl="";

          this.numLines = 0;

          this.editor = null;

          // currently active keywords
          this.keywordInfo = {
            keywords: [],
            ranges: []
          };
        },

        ready: function () {
          this.$.iframe.src=this.iframeurl;

          // keywordlist fired from content script
          document.addEventListener('keywordlist', function (e) {
            setKeywordInfo(self,e.detail);
          });

          var self=this;
          this.$.iframe.onload = function () {
            handleIframeLoad(self);
          };
        },

        // API functions
        enablePointerEvents: function () {
          this.$.iframe.classList.remove('nopointerevents');
        },

        disablePointerEvents: function () {
          this.$.iframe.classList.add('nopointerevents');
        },

        // propertyChanged handlers
        iframeurlChanged: function (oldValue,newValue) {
          this.$.iframe.src=newValue;
        },

        // event handlers

        onMouseOverImage: function (e) {
          this.$.highlighter.turn(e.detail.groupId,'on');
        },

        onMouseOutImage: function (e) {
          this.$.highlighter.turn(e.detail.groupId,'off');
        },

      }); // Polymer()
    })();

  </script>
</polymer-element>

