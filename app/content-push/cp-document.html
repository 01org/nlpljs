/**
 * cp-document
 */

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel='import' href='./cp-scrollwatcher.html'>
<link rel='import' href='./cp-keyword-highlighter.html'>

<polymer-element
  name='cp-document'
  on-mouseoverimage='{{onMouseOverImage}}'
  on-mouseoutimage='{{onMouseOutImage}}'
  attributes='iframeurl'>
  <template>
    <style>
      :host {
        position: relative;
      }

      #iframe {
        position: absolute;
        display: block;
        background-color: #f0f0f0;
        height: 100%;
        width: 100%;
        border: none;
      }

      #iframe.nopointerevents {
        pointer-events: none;
      };
    </style>
    <iframe id="iframe"></iframe>
    <cp-keyword-highlighter id='highlighter'></cp-keyword-highlighter>
    <cp-scrollwatcher id='scrollwatcher'></cp-scrollwatcher>
  </template>
  <script>
    (function cpDocument () {
      // private *static* functions and constants
      var LINE_CLASS = 'kix-lineview';        /* Handle to the current Page */
      var LINE_SELECTOR = '.kix-lineview';
      var SCROLLING_ELEMENT_SELECTOR = '.kix-appview-editor';

      /**
       * find ancestor of node that has className
       * for finding the ancestor with .kix-lineview of whatever line has changed
       */
      var findAncestor = function (node,className) {
        var retVal=null;

        var thisNode=node;
        var cssSelectorNotFound=true;

        while (cssSelectorNotFound && thisNode && thisNode.nodeName!="BODY") {
          cssSelectorNotFound=!thisNode.classList.contains(className);
          if (cssSelectorNotFound) {
            // move into parent node
            thisNode=thisNode.parentNode;
          } else {
            // finished
            retVal=thisNode;
          }
        }

        return retVal;
      };

      var observeDocumentChanges = function (self) {
        var observer = new MutationObserver(function (mutations,observerInstance) {
          for (var i = 0; i < mutations.length; i++) {
            var mutation = mutations[i];
            var newNodes = mutation.addedNodes;
            var removedNodes = mutation.removedNodes;

            if (removedNodes !== null) {
              for (var j = 0; j < removedNodes.length; j++) {
                var thisNode = removedNodes[j];
                if (thisNode) {
                  if (typeof thisNode.classList !== 'undefined' &&
                      thisNode.classList.contains(LINE_CLASS) &&
                      thisNode.getAttribute('cp_line_id') !== null &&
                      self.$.scrollwatcher.isNodeVisible(thisNode)) {
                    console.log('MO:removed line');

                    self.$.scrollwatcher.removeTargetNode(thisNode);

                    if (self.editOverTimer !== null)
                      clearTimeout(self.editOverTimer);

                    self.editOverTimer = setTimeout(function () {
                      self.$.scrollwatcher.getVisibleNodes(getContext, self);
                    }, self.editOverTimeout);
                  }
                }
              }
            }

            if (newNodes !== null) {
              for (var j = 0; j < newNodes.length; j++) {
                var thisNode = newNodes[j];
                if (thisNode) {
                  if (thisNode.nodeName === 'SPAN') {
                    var line = findAncestor(thisNode, LINE_CLASS);

                    if (line !== null &&
                        line.getAttribute('cp_line_id') !== null &&
                        self.$.scrollwatcher.isNodeVisible(line) &&
                        line.innerHTML.indexOf('keyword-highlight') === -1) {
                      console.log('MO:editing line');

                      if (self.editOverTimer !== null)
                        clearTimeout(self.editOverTimer);

                      self.editOverTimer = setTimeout(function () {
                        self.$.scrollwatcher.getVisibleNodes(getContext, self);
                      }, self.editOverTimeout);
                    }
                  }
                  else if (typeof thisNode.classList !== 'undefined' &&
                           thisNode.classList.contains(LINE_CLASS) &&
                           thisNode.getAttribute('cp_line_id') === null) {
                    console.log('MO:new line');
                    addIdToLine(thisNode, self.lineIdAccumulator);
                    self.lineIdAccumulator++;

                    self.$.scrollwatcher.addTargetNode(thisNode);

                    if (self.$.scrollwatcher.isNodeVisible(thisNode)) {
                      if (self.editOverTimer !== null)
                        clearTimeout(self.editOverTimer);

                      self.editOverTimer = setTimeout(function () {
                        self.$.scrollwatcher.getVisibleNodes(getContext, self);
                      }, self.editOverTimeout);
                    }
                  }
                }
              }
            }
          }
        });

        // Configuration of the observer:
        var config = {
          attributes: false,
          childList: true,
          subtree: true,
          characterData: false
        };

        // Pass in the target node, as well as the observer options
        observer.observe(self.$.iframe.contentDocument, config);
      };

      var handleIframeLoad = function (self){
        var lines =
          self.$.iframe.contentDocument.querySelectorAll(LINE_SELECTOR);

        var editor =
          self.$.iframe.contentDocument.querySelector(SCROLLING_ELEMENT_SELECTOR);

        self.$.highlighter.targetElement = self.$.iframe.contentDocument;

        self.$.scrollwatcher.setScrollableNode(editor);
        self.$.scrollwatcher.addOnScrollListener(getContext, self);

        for (var i = 0; i < lines.length; i++) {
          addIdToLine(lines[i], self.lineIdAccumulator);
          self.lineIdAccumulator++;

          self.$.scrollwatcher.addTargetNode(lines[i]);
        }

        self.$.scrollwatcher.getVisibleNodes(getContext, self);

        observeDocumentChanges(self);
      };

      var addIdToLine = function (line, value) {
        var lineIdAtt = document.createAttribute('cp_line_id');

        lineIdAtt.value = value;
        line.setAttributeNode(lineIdAtt);
      };

      var getContext = function (context, self) {
        self.fire('newcontext', {});

        for (var i = 0; i < context.length; i++) {
          var lineId;
          var prevLineId = -1;

          lineId = context[i].getAttribute('cp_line_id');

          if (i > 0)
            prevLineId = context[i - 1].getAttribute('cp_line_id');

          self.fire('lineadded',
            {
              lineId: lineId,
              prevLineId: prevLineId,
              text: context[i].innerText
            }
          );
        }

        self.fire('processcontext', {});
        self.fire('getkeywords', {});
      };

      /**
       * Add an image card (gallery) for the current page;
       * if the image card exists for this page already, do not
       * add the element, but just set the keywordInfo.
       */
      var setKeywordInfo = function (self, keywordInfo) {
        self.keywordInfo = keywordInfo;
        self.fire('newkeywordinfo',{keywordInfo: keywordInfo});

        self.$.highlighter.clear();
        self.$.highlighter.prepare(keywordInfo.ranges);

      };

      Polymer({
        // functions and properties used in API and bindings
        // life cycle handlers
        editOverTimeout: 500,
        editOverTimer: null,
        created: function () {
          this.iframeurl="";

          this.lineIdAccumulator = 0;

          // currently active keywords
          this.keywordInfo = {
            keywords: [],
            ranges: []
          };
        },

        ready: function () {
          this.$.iframe.src=this.iframeurl;

          // keywordlist fired from content script
          document.addEventListener('keywordlist', function (e) {
            setKeywordInfo(self,e.detail);
          });

          var self=this;
          this.$.iframe.onload = function () {
            handleIframeLoad(self);
          };
        },

        // API functions
        enablePointerEvents: function () {
          this.$.iframe.classList.remove('nopointerevents');
        },

        disablePointerEvents: function () {
          this.$.iframe.classList.add('nopointerevents');
        },

        // propertyChanged handlers
        iframeurlChanged: function (oldValue,newValue) {
          this.$.iframe.src=newValue;
        },

        // event handlers

        onMouseOverImage: function (e) {
          for (var i = 0; i < e.detail.length; i++)
            this.$.highlighter.turn(e.detail[i].groupId,'on');
        },

        onMouseOutImage: function (e) {
          for (var i = 0; i < e.detail.length; i++)
            this.$.highlighter.turn(e.detail[i].groupId,'off');
        },

      }); // Polymer()
    })();

  </script>
</polymer-element>

