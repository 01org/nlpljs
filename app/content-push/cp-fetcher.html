<link rel="import" href="./cp-search-wikipedia.html">
<link rel="import" href="./cp-search-google-images.html">
<link rel="import" href="./cp-search-google-files.html">

<polymer-element name="cp-fetcher" attributes="resultsPerFetch">
  <template>
    <cp-search-wikipedia id="searchWikipedia"
                         resultsPerFetch="{{resultsPerFetch}}">
    </cp-search-wikipedia>

    <cp-search-google-images id="searchGoogleImages"
                               resultsPerFetch="{{resultsPerFetch}}">
    </cp-search-google-images>

    <cp-search-google-files id="searchGoogleFiles"
                               resultsPerFetch="{{resultsPerFetch}}">
    </cp-search-google-files>

  </template>

  <script src="./cp-filter-deduplicate.js"></script>

  <script>
    (function () {
      // for testing for PDF or SVG files returned as image results
      var BAD_EXTENSIONS_REGEX = /\.(pdf|svg)$/i;

      Polymer({
        created: function () {
          this.urlDeduplicator = new FilterDeduplicate();
        },

        // number of results to fetch per call to the fetch() method
        resultsPerFetch: 5,

        /* at the moment we just fetch and aggregate via the
           cp-search-wikipedia component; returns a promise
           which resolves to an array of results or rejects with an error */
        fetch: function (keyword) {
          var self = this;

          var query = keyword.text;

          console.log('searching for ' + query);

          if (!query) {
            return Promise.resolve([]);
          }

          var promises = [
            //this.$.searchWikipedia.fetch(query),
            this.$.searchGoogleImages.fetch(query),
            this.$.searchGoogleFiles.fetch(query),
          ];

          return Promise.all(promises).then(
            function (allResults) {
              var filteredResults = [];

              console.log('CP-FETCHER:allResults.length:',allResults.length);
              for (var j = 0; j < allResults.length; j++) {
                var results=allResults[j];
                console.log('CP-FETCHER:results.length:',results.length);
                for (var i = 0; i < results.length; i++) {
                  /* filter out any pdfs or svg files */
                  if (!BAD_EXTENSIONS_REGEX.test(results[i].src) &&
                      self.urlDeduplicator.test(results[i].src)) {
                    results[i].keyword = keyword;

                    /* record the URL for future deduplication */
                    self.urlDeduplicator.addComparisonValue(results[i].src);

                    filteredResults.push(results[i]);
                  }
                }
              }

              console.log('CP-FETCHER:filteredResults.length:',filteredResults.length);

              return Promise.resolve(filteredResults);
            },

            function (err) {
              return Promise.reject(err);
            }
          );
        }
      });
    })();
  </script>
</polymer-element>
