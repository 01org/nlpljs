<link rel="import" href="./cp-search-google-images.html">
<link rel="import" href="./cp-search-wikipedia.html">
<link rel="import" href="./cp-search-google-files.html">

<polymer-element name="cp-fetcher" attributes="resultsPerFetch">
  <template>
    <cp-search-google-images id="searchGoogleImages"
                             resultsPerFetch="{{resultsPerFetch}}">
    </cp-search-google-images>

    <cp-search-wikipedia id="searchWikipedia"
                         resultsPerFetch="{{resultsPerFetch}}">
    </cp-search-wikipedia>

    <cp-search-google-files id="searchDrive"
                            resultsPerFetch="{{resultsPerFetch}}">
    </cp-search-google-files>
  </template>

  <script src="./cp-filter-deduplicate.js"></script>

  <script>
    (function () {
      // for testing for PDF or SVG files returned as image results
      var BAD_EXTENSIONS_REGEX = /\.(pdf|svg)$/i;

      Polymer({
        created: function () {
          this.urlDeduplicator = new FilterDeduplicate();
        },

        // number of results to fetch per call to the fetch() method
        resultsPerFetch: 5,

        /* at the moment we just fetch and aggregate via the
           cp-search-wikipedia component; returns a promise
           which resolves to an array of results or rejects with an error */
        fetch: function (keyword, preferredService) {
          var self = this;

          var query = keyword.text;

          var source;

          console.log('searching for ' + query);

          if (!query) {
            return Promise.resolve([]);
          }

          switch (preferredService) {
            case "Google Image Search":
              source = this.$.searchGoogleImages;
              break;
            case "Wikipedia Image Search":
              source = this.$.searchWikipedia;
              break;
            case "Google Drive Search":
              source = this.$.searchDrive;
              break;
            default:
              console.warn("cp-fetcher: Unrecognized preferred service!");
              return Promise.resolve([]);
          }

          return source.fetch(query).then(
            function (results) {
              var filteredResults = [];

              for (var i = 0; i < results.length; i++) {
                /* filter out any pdfs or svg files */
                if (!BAD_EXTENSIONS_REGEX.test(results[i].src) &&
                    self.urlDeduplicator.test(results[i].source)) {
                  results[i].keyword = keyword;

                  /* record the URL for future deduplication */
                  self.urlDeduplicator.addComparisonValue(results[i].source);

                  filteredResults.push(results[i]);
                }
              }

              return Promise.resolve(filteredResults);
            },

            function (err) {
              return Promise.reject(err);
            }
          );
        }
      });
    })();
  </script>
</polymer-element>
