/*
  implements keyword highlighting functionality

  attributes:
    onStyle: the style to set when the highlighting is 'on'
    default:
      background-color: lightpink;

    offStyle: the style to set when the highlighting is 'off'
    default: none

  targetElement:
    set to the element containing the google doc, eg :
    this.$.highlighter.targetElement = this.$.iframe.contentDocument;

  prepare(ranges):
    insert the html for the given ranges (in 'off' mode)
    ranges is (first line/char is '0'):
    [
      {
        groupId: 1,
        start: {
          lineNo: 2,
          charNo: 5
        },
        end: {
          lineNo: 2,
          charNo: 15
        }
      },
      ...
    ]

  turn(groupId,'on'|'off'):
    turns the highlighing on or off for the specific groupId

  clear([groupId]);
    removes the html for the given groupId, or if no groupId given, all of them.
*/

<polymer-element name='keyword-highlighter' attributes='onStyle offStyle'>
  <script>
    (function keywordHighlighter() {
      // private properties
      var hl={
        open: function(groupId,tag) { return '<keyword-highlight debugTag="'+tag+'" group-id="'+groupId+'">'; },
        close: function() { return '</keyword-highlight>'; }
      };

      var nbsp='&nbsp;';

      /*
         skip any number of tags next to each other
         eg: <tag><tag>
         chars - the whole string
         start - the position of the first '<'
         returns - the position after the last '>'
       */
      var skipTags = function(chars,start) {
        var retVal=(start)?start:0;

        while (chars[retVal]==='<' && retVal<chars.length) {
          var endOfTag=chars.indexOf('>',retVal);
          retVal=endOfTag+1;
        }

        return retVal;
      };

      /*
         splits a string at (non-html) character position
         ignoring html tags and counting '&nbsp;' as one character

         position - the (non-html) character position to split at
         chars - the whole string, html and all
         endian - 'begin' if this is for the beginning of a 'range', or
                  'end' if this is at the end of a 'range'
       */
      var splitAtPosition = function(position,chars,endian) {
        var retVal = {
          before: null,
          after: null
        };

        var sanityCheck=0;
        var SANITYMAXLOOPS=1000; // picked out of thin air
        function outputSanityMessage() {
          console.log('HL:sanity check: loop unreasonable long; breaking');
          console.log('%cHL:TELL MAX ABOUT ABOVE ERROR','color:orange; background:red; font-size: 16pt;');
        }

        // replace nbsp with char 160 to make life simpler
        var re = new RegExp('&nbsp;', 'g');
        var fakeSpace=String.fromCharCode(160);
        chars = chars.replace(re,fakeSpace);

        var currentPosition=0;

        // TODO: examine the two endian cases and combine
        if (endian==='begin') {
          var endOfTag=skipTags(chars);
          currentPosition=endOfTag;
          var keywordChars=0;
          var nextTag=chars.indexOf('<',currentPosition);
          while (nextTag!==-1 && nextTag <= currentPosition+position-keywordChars) {
            // update current count of keyword characters
            keywordChars+=nextTag-currentPosition;

            // move to next tag
            currentPosition=nextTag;

            if (++sanityCheck>SANITYMAXLOOPS) {
              outputSanityMessage();
              break;
            }

            // skip past tag(s)
            currentPosition=skipTags(chars,currentPosition);

            nextTag=chars.indexOf('<',currentPosition);
          }
          currentPosition+=position-keywordChars; // *before* position
        } else
        if (endian==='end') {
          var nextTag=chars.indexOf('<');
          if (nextTag===-1) {
            currentPosition=chars.length;
          } else {
            var endOfTags=skipTags(chars);
            currentPosition=endOfTags;
            var keywordChars=0;
            var nextTag=chars.indexOf('<',currentPosition);
            var sanityCheck=0;
            while (nextTag!==-1 && nextTag < currentPosition+position-keywordChars+1) {
              // update current count of keyword characters
              keywordChars+=nextTag-currentPosition;

              // move to next tag
              currentPosition=nextTag;

              if (++sanityCheck>SANITYMAXLOOPS) {
                outputSanityMessage();
                break;
              }

              if (keywordChars<=position) {
                // skip past tag(s)
                currentPosition=skipTags(chars,currentPosition);

                // find next tag
                nextTag=chars.indexOf('<',currentPosition);
              } else {
                break;
              }
            }
            currentPosition+=position-keywordChars+1; // *after* position
          }
        }

        // replace char 160 with nbsp again
        var re = new RegExp(fakeSpace, 'g');
        retVal.before=chars.substr(0,currentPosition).replace(re,nbsp);
        retVal.after=chars.substr(currentPosition).replace(re,nbsp);

        return retVal;
      };

      var getLine = function(self,lineNo) {
        var retVal = self.targetElement.querySelectorAll(
          '.kix-lineview-content'
        )[lineNo];

        return retVal;
      };

      // tries to behave like html parser does
      // wrt to white space
      var compressWhiteSpace = function(html) {
        var retVal = html;

        // compress multiple white space into one
        retVal = retVal.replace(/\s+/, ' ');

        // remove white space at the beginning of line
        retVal = retVal.replace(/^\s+/,'');

        // remove white space at the end of line
        retVal = retVal.replace(/\s+$/,'');

        return retVal;
      };

      var highlightRange = function(self,rangeToHighlight) {
        var start=rangeToHighlight.start;
        var end=rangeToHighlight.end;
        var groupId=rangeToHighlight.groupId;

        var tag = [
          [start.lineNo,start.charNo].join(':'),
          [end.lineNo,end.charNo].join(':'),
        ].join('-');

        // 1. get start line object
        var line=getLine(self,start.lineNo);

        // abort if no line
        if (!line) {
          console.log('HL:ERROR, line#%d not found.',start.lineNo);
          return;
        }

        // 2. split the lines html at start char
        var bits0=splitAtPosition(
          start.charNo,
          compressWhiteSpace(line.innerHTML),
          'begin'
        );

        // 3. add close hl before first '<' in .after0
        var closePosition=bits0.after.indexOf('<');
        if (end.lineNo===start.lineNo) {
          // use splitAtPosition to find
          // if the split would be before the '<'
          var tmpBits=splitAtPosition(
            end.charNo-start.charNo,
            bits0.after,
            'end');
          if (tmpBits.before.length<closePosition) {
            closePosition=tmpBits.before.length;
          }
        }
        bits0.after = [
          bits0.after.substr(0,closePosition),
          hl.close(),
          bits0.after.substr(closePosition)
        ].join('');

        // 4. if end char is on same line as start char
        if (end.lineNo===start.lineNo) {
          // 4.1 in .after0, split line at (end char - start char)
          var bits1=splitAtPosition(
            end.charNo-start.charNo,
            bits0.after,
            'end'
          );

          // 4.2 in .before1, replace />([^>]+)</ with hl.open(groupId) \1 hl.close()
          bits1.before = bits1.before.replace(
            />([^<]+)</g,
            [
              '>',
              hl.open(groupId,tag),
              '$1',
              hl.close(),
              '<'
            ].join('')
          );

          // 4.2a in .before1, surround any plain text at the end of the line with hl
          bits1.before = bits1.before.replace(
            />([^>]+)$/,
            [
              '>',
              hl.open(groupId,tag),
              '$1',
              hl.close()
            ].join('')
          );

          // 4.3 join the .before1, .after1 together
          // 4.4 assign to .after0
          bits0.after=[
            bits1.before,
            bits1.after
          ].join('');
          // # done close on same line
        } else {
          // 5. if end char is not on start line

          // 5.1 in .after0, replace />([^<]+)</ with hl.open(groupId) $1 hl.close()
          bits0.after = bits0.after.replace(
            />([^<]+)</g,
            [
              '>',
              hl.open(groupId,tag),
              '$1',
              hl.close(),
              '<'
            ].join('')
          );
        }

        // 6. join the .before0, open hl, .after0 together
        // 7. assign the line to start line object
        line.innerHTML=[
          bits0.before,
          hl.open(groupId,tag),
          bits0.after
        ].join('');
        // # done first line including hl.close() if it's on the same line


        // 7. if end line > start line
        if (end.lineNo>start.lineNo) {
          // # process intermediate lines

          // 7.1 loop over intermediate lines ie lineNo=startLine+1;lineNo<endLine;lineNo++
          for (var lineNo=start.lineNo+1;lineNo<end.lineNo;++lineNo) {
            // 7.2.1 get line object
            var thisLine=getLine(self,lineNo);

            // 7.2.2 replace />([^<]+)</ with hl.open(groupId) \1 hl.close()
            var thisHTML=compressWhiteSpace(thisLine.innerHTML).replace(
              />([^<]+)</g,
              [
                '>',
                hl.open(groupId,tag),
                '$1',
                hl.close(),
                '<'
              ].join('')
            );
            
            // 7.2.3 assign to the line object
            thisLine.innerHTML=thisHTML;
          }

          // # process last line
          // 7.3 get last line object
          var endLine=getLine(self,end.lineNo);

          // 7.4 split it at the end char
          var bits=splitAtPosition(
            end.charNo+1, // include last character
            compressWhiteSpace(endLine.innerHTML),
            'end'
          );

          // 7.5 in .before, replace />([^<]+)</ with hl.open(groupId) \1 hl.close()
          bits.before = bits.before.replace(
            />([^<]+)</g,
            [
              '>',
              hl.open(groupId,tag),
              '$1',
              hl.close(),
              '<'
            ].join('')
          );
          
          // 7.5a in .before add hl.open(groupId) after final '>'
          var gtPosition = bits.before.lastIndexOf('>');
          if (gtPosition!=-1) {
            var insertAtPos=gtPosition+1;
            bits.before = [
              bits.before.substr(0,insertAtPos),
              hl.open(groupId,tag),
              bits.before.substr(insertAtPos)
            ].join('');
          }

          // 7.6 join the .before, close hl, .after together
          // 7.7 assign to the last line object
          endLine.innerHTML=[
            bits.before,
            hl.close(),
            bits.after
          ].join('');
        }


        // dump the contents of the range highlighted
        console.log('HL:Tag:',tag);
        var elements=self.targetElement.querySelectorAll('keyword-highlight[debugTag="'+tag+'"]');
        var result=[];
        for ( var i=0;i<elements.length;++i ) {
          result.push(elements[i].innerText);
        }
        var concatResult=[result.join('')].join('');
        console.log('HL:Result: ',['/',concatResult,'/'].join(''));
        if (start.lineNo===end.lineNo && concatResult.length!=(end.charNo-start.charNo+1)) {
          // only checking when the same line
          console.log('HL:Error: concatResult length=',concatResult.length);
          console.log('HL:Error: end.charNo-start.charNo+1=',end.charNo-start.charNo+1);
        }
      };

      /*
         Injects the css for the on and off style into the head.
       */
      var injectCss = function(self, targetDocument) {
        var css=[
          'keyword-highlight,',
          'keyword-highlighter-test::shadow keyword-highlight {',
            self.offStyle,
          '}',
          'keyword-highlight.on,',
          'keyword-highlighter-test::shadow keyword-highlight.on {',
            self.onStyle,
          '}',
        ].join('\n');

        head = targetDocument.head || targetDocument.getElementsByTagName('head')[0];
        style = targetDocument.createElement('style');
        style.type = 'text/css';
        if (style.styleSheet){
          style.styleSheet.cssText = css;
        } else {
          style.appendChild(document.createTextNode(css));
        }

        head.appendChild(style);
      };

      Polymer({
        created: function() {
          this.offStyle='',
          this.onStyle=[
            'background-color: lightpink;'
          ].join('');
        },

        ready: function() {
        },

        targetElementChanged: function(oldValue,newValue) {
          var targetDocument=this.targetElement.ownerDocument ||
            this.targetElement.body.ownerDocument;

          injectCss(this, targetDocument);
        },

        prepare: function(ranges) {
          for (var i=0;i<ranges.length;++i) {
            highlightRange(this,ranges[i]);
          }
        },

        turn: function(groupId,state) {
          if (state==='on') {
            var elements=this.targetElement.querySelectorAll(
              'keyword-highlight[group-id="'+groupId+'"]:not(.on)'
            );

            for (var i=0, element; element = elements[i]; i++) {
              element.classList.add('on');
            }
          } else {
            var elements=this.targetElement.querySelectorAll(
              'keyword-highlight.on[group-id="'+groupId+'"]'
            );

            for (var i=0, element; element = elements[i]; i++) {
              element.classList.remove('on');
            }
          }
        },

        clear: function(groupId) {

          // get the elements with the given groupId,
          // or all if non given
          var elements=this.targetElement.querySelectorAll([
            'keyword-highlight',
            (groupId)?'[group-id="'+groupId+'"]':''
          ].join(''));

          // remove each element in turn
          for (var elementIndex=0;elementIndex<elements.length;++elementIndex) {
            var thisElement=elements[elementIndex];
            var parent=thisElement.parentNode;

            // move children to before thisElement
            while (thisElement.firstChild) {
              var child=thisElement.firstChild;
              parent.insertBefore(child,thisElement);
            }

            // remove thisElement
            parent.removeChild(thisElement);
          }
        },

        // for testing only
        testSplitAtPosition: function(position,chars,endian) {
          return splitAtPosition(position,chars,endian);
        },

      }); // Polymer()
    })();

  </script>
</polymer-element>
