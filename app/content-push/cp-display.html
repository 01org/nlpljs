<!--
scrolling image search results component; responsible for tracking
the state of any ongoing search, displaying loading spinners, and
pushing new tiles into the wrapped layout
-->
<link rel="import" href="../bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="../bower_components/paper-slider/paper-slider.html">
<link rel="import" href="./cp-scroll.html">
<link rel="import" href="./cp-layout.html">

<polymer-element name="cp-display">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      .fill {
        width: 100%;
        height: 100%;
      }

      .message-area {
        text-align: center;
        width: 60%;
        margin-left: 20%;
        box-sizing: border-box;
      }

      #preresults {
        padding-top: 3em;
      }

      #results {
        position: relative;
      }

      #loading {
        display: flex;
        background-color: white;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1000;
        opacity: 0.6;
      }

      [data-show="false"] {
        display: none !important;
      }

      #scroller {
        height: 92%;
      }

      #widen {
        position: absolute;
        bottom: 0;
        width: 100%;
        height: 8%;
        min-height: 64px;
        background-color: white;
      }

      paper-slider {
        width: 100%;
        height: 100%;
        padding: 8px 0;
      }

      /* slider colors (oh dear...) */
      /* bar */
      paper-slider::shadow #sliderBar::shadow #activeProgress {
        background-color: #0f9d58;
      }

      /* knob */
      paper-slider::shadow #sliderKnobInner {
        background-color: #0f9d58;
      }
    </style>

    <!--
    states for this component:

    - preresults - no search initiated, displays welcome message
    - results - "widen" is shown with results (or empty results)
    -->

    <!-- never searched -->
    <div id="preresults" class="message-area"
         data-show="{{state === 'preresults'}}">
      <p>Your related content should arrive shortly.</p>
      <paper-spinner active></paper-spinner>
    </div>

    <!-- after results are found -->
    <div id="results" class="fill"
         data-show="{{state === 'results'">
      <!-- full page loader; can overlay image display -->
      <div id="loading" class="fill" data-show="{{loading && state !== 'preresults'}}">
        <paper-spinner active></paper-spinner>
      </div>

      <!-- image display -->
      <cp-scroll id="scroller" class="fill"
                 on-scrollend="{{onScrollerScrollend}}"
                 data-show="{{state === 'results'}}">
        <!-- results -->
        <cp-layout id="layout" class="fill"
                   data-show="{{state === 'results'}}">
        </cp-layout>
      </cp-scroll>

      <!-- "widen the search" slider -->
      <div id="widen" data-show="{{state !== 'preresults'}}">
        <paper-slider min="0" max="100" value="50">
        </paper-slider>
      </div>
    </div>
  </template>

  <script src="../bower_components/lodash/dist/lodash.js"></script>

  <script>
    (function () {
      Polymer({
        /* state of the results; 'preresults' or 'results' */
        state: 'preresults',

        /* whether we are loading or not */
        loading: false,

        /**
         * Set criteria for filtering the content of the display.
         *
         * @param {object} criteria Criteria for the filter
         * @param {object} criteria.keywordInfo KeywordInfo object with
         * this structure:
         * {
         *   keywords: [ { text: <text>, ...}, ... ],
         *   types: ['image', 'quotation', ...]
         * }
         *
         * Right now, the first keyword in the keywordInfo.keywords
         * array is used as the filter. Any tile whose keyword.text
         * property matches this active keyword and has a type
         * matching one of the members of "types" will be displayed.
         */
        setFilter: function (criteria) {
          var self = this;

          if (!criteria.activeKeywords) {
            return;
          }

          var keywords = criteria.activeKeywords.map(function (keyword) {
            return keyword.text;
          });

          criteria.types = criteria.types || [];

          /* set the filter on the layout to the current keyphrase */
          this.$.layout.setFilter(function (tile) {
            var keywordMatches = false;
            for (var i = 0; i < tile.keywords.length; i++) {
              var index = keywords.indexOf(tile.keywords[i].text);
              if (index !== -1) {
                keywordMatches = true;
                tile.keywords[i] = criteria.activeKeywords[index];
              }
            }

            if (!keywordMatches) {
              return false;
            }

            tile.ke
            var typeMatches;
            /* no types criteria, so always matches */
            if (criteria.types.length === 0) {
              typeMatches = true;
            } else {
              typeMatches = _.contains(criteria.types, tile.image.type);
            }

            return keywordMatches && typeMatches;
          });
        },

        /**
         * Add results to the layout.
         *
         * Each result in the results array should look like:
         * {
         *   src: <url of image>,
         *   keyword: {
         *     text: <keyphrase text>,
         *     groupId: <keyphrase groupId>
         *   },
         *   meta: { ... metadata ... },
         *   caption: <image caption>,
         *   source: <url of image source>
         * }
         */
        receiveResults: function (results) {
          this.state = 'results';

          if (results.length) {
            for (var i = 0; i < results.length; i++) {
              this.appendImage(results[i]);
            }
          } else {
            this.layout();
          }
        },

        onScrollerScrollend: function () {
          this.fire('moreresults');
        },

        /**
        * Convenience method to append an image tile to the
        * gallery; creates a cp-tile-image element for the image
        * object added.
        *
        * @param Object image Representation of image to add; has the
        * format:
        * {
        *   thumbnailSrc: "<url of image thumbnail>",
        *   width: <width of full-size image>,
        *   height: <height of full-size image>,
        *   keyword: {
        *       text: "<keyphrase text>",
        *       groupId: "<keyphrase group ID>"
        *   },
        *   type: 'image'
        * }
        *
        * The keyphrase groupId is assigned by the NLP engine and
        * enables the Highlighter to identify the correct ranges
        * in the Context when highlights are toggled.
        */
        appendImage: function (image) {
          var self = this;

          var elt = document.createElement('cp-tile-image');

          elt.src = image.thumbnailSrc;
          elt.width = image.width;
          elt.height = image.height;

          if (elt.keywords.indexOf(image.keyword) === -1)
            elt.keywords[elt.keywords.length] = image.keyword;

          elt.addEventListener('mouseover', function () {
            self.fire('mouse-over', elt.keywords);
          });

          elt.addEventListener('mouseout', function () {
            self.fire('mouse-out', elt.keywords);
          });

          elt.addEventListener('click', function () {
            self.fire('mouse-down', elt);
          });

          elt.image = image;

          this.$.layout.addTile(elt);
        },

        getLayout: function () {
          return this.$.layout;
        },

        /* layout the wrapped cp-layout */
        layout: function () {
          this.$.layout.layout();
        },

        /* reset scroller to top */
        scrollToTop: function () {
          this.$.scroller.scrollTop = 0;
        },

        showLoadingSpinner: function () {
          this.loading = true;
        },

        hideLoadingSpinner: function () {
          this.loading = false;
        }
      });
    })();
  </script>
</polymer-element>
