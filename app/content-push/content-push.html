<link rel="import" href="../bower_components/core-splitter/core-splitter.html">
<link rel="import" href="../bower_components/core-toolbar/core-toolbar.html">
<link rel="import" href="../bower_components/core-icon-button/core-icon-button.html">
<link rel="import" href="../bower_components/core-header-panel/core-header-panel.html">
<link rel="import" href="../bower_components/core-animated-pages/core-animated-pages.html">
<link rel="import" href="../bower_components/core-animated-pages/transitions/slide-from-right.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-tabs/paper-tabs.html">
<link rel="import" href="./image-card.html">
<link rel='import' href='./keyword-highlighter.html'>

<polymer-element name="content-push" attributes="iframeurl toggle">
  <template>
    <link type="text/css" rel="stylesheet" href="ClearSans/ClearSans.css">
    <link type="text/css" rel="stylesheet" href="styles/content-push.css">
    <div id="container" horizontal layout>
      <iframe id="iframe" flex></iframe>
      <core-splitter id="splitter" direction="right" minSize="300px" on-down="{{downAction}}" on-up="{{upAction}}" on-track="{{trackAction}}"></core-splitter>
      <div id="content_push_panel">
        <!--the panel is made up of a header toolbar, a content toolbar and the content-->
        <core-toolbar id="toolbar">
          <div id="toolbartext" flex>Content Push</div>
          <core-icon-button id="toolbaraction" icon="close" on-tap="{{closePanel}}"></core-icon-button>
        </core-toolbar>

        <!--Tabs Menu-->
        <core-toolbar id="tabs-toolbar">
          <paper-tabs id="tabs" noink>
            <paper-tab>
              <paper-button icon="drive-image"></paper-button>
            </paper-tab>
            <paper-tab>
              <paper-button icon="drive"></paper-button>
            </paper-tab>
            <paper-tab>
              <paper-button icon="subject"></paper-button>
            </paper-tab>
            <paper-tab>
              <paper-button icon="more-vert"></paper-button>
            </paper-tab>
          </paper-tabs>
        </core-toolbar>

        <core-animated-pages id='content' transitions="slide-from-right">
        </core-animated-pages>
      </div><!-- content_push_panel -->
    </div><!-- container -->
    <keyword-highlighter id='highlighter'></keyword-highlighter>
  </template>

  <script>
    (function contentPushApp() {
      // private properties

      /* find ancestor of node that has className
      for finding the ancestor with .kix-lineview of whatever line has changed */
      var findAncestor = function(node,className) {
        var retVal=null;

        var thisNode=node;
        var cssSelectorNotFound=true;

        while (cssSelectorNotFound && thisNode && thisNode.nodeName!="BODY") {
          cssSelectorNotFound=!thisNode.classList.contains(className);
          if (cssSelectorNotFound) {
            // move into parent node
            thisNode=thisNode.parentNode;
          } else {
            // finished
            retVal=thisNode;
          }
        }

        return retVal;
      };

      // NOTE: doesn't handle removed lines
      var observeDocumentChanges = function(iframe,callBack) {
        var docsContainerSelector = ".kix-paginateddocumentplugin";
        var docsFilterSelector = ".kix-lineview";

        // Create an observer instance
        var observer = new MutationObserver(function(mutations,observerInstance) {
          mutations.forEach(function(mutation) {
            var newNodes = mutation.addedNodes; // DOM NodeList
            if (newNodes !== null) { // If there are new nodes added
              for (var i=0;i<newNodes.length;++i) {
                var thisNode=newNodes[i];
                if (thisNode) {
                  var lineview=(thisNode.classList.contains("kix-lineview"))?thisNode:findAncestor(thisNode,"kix-lineview");
                  if (lineview) {
                    callBack(lineview.textContent);
                  }
                }
              }
            }
          });
        });

        // Configuration of the observer:
        var config = {
          attributes: true,
          childList: true,
          subtree: true,
          characterData: true
        };

        // Pass in the target node, as well as the observer options
        var node=iframe.contentDocument.querySelector(docsContainerSelector);
        observer.observe(node, config);
      };

      Polymer({
        open:true,
        editor:null,
        scrollTimer:0,
        pageno:1, //Current Page numer the user is on
        page:null, //Current page
        sectionIndex:[],
        sectionCount:0,
        /* map from page IDs to image-card elements; each page gets
        its own image-card element (at the moment)*/
        imageCards: {},

        created: function() {
          this.iframeurl="";
        },

        iframeurlChanged: function(oldValue,newValue) {
          //console.log("CP:new iframeurl:",newValue);
          self.$.iframe.src=newValue;
        },

        toggleChanged: function(oldValue,newValue) {
          this.togglePanel();
        },

        ready: function() {
          self=this;
          self.$.iframe.src=self.iframeurl;

          // Add a iframe onLoad handler
          var onLoadHandler = this.onLoad.bind(this);
          self.$.iframe.onload = onLoadHandler;

          var tabselect = this.tabSelected.bind(this);
          self.$.tabs.addEventListener('core-select', tabselect);
        },

        domReady: function () {
          //TODO trigger searches from the real text on the page
          //this.search(pageId, ['stub phrase', 'stub phrase']);
        },

        tabSelected: function(e) {
          if (!e.detail.isSelected)
            return;

          switch(parseInt(this.$.tabs.selected)){
            case 0:
              this.loadImages();
              break;
            case 1:
              this.loadDrive();
              break;
            case 2:
              this.loadQuotes();
              break;
            case 3:
              this.loadMore();
              break;
            default:
          }
        },

        loadImages: function() {
          console.log('load images');
        },

        loadDrive: function() {

        },

        loadQuotes: function() {

        },

        loadMore: function() {
          observeDocumentChanges(self.$.iframe, function(text) {
            var textNode=document.createTextNode(text.replace("&nbsp;"," "));
            self.$.changed_text.innerHTML="";
            self.$.changed_text.appendChild(textNode);
          });

          // bind event handlers to search components
          //var handler = this.handleSearchResults.bind(this);
          //this.$.search_google_images.addEventListener("searchResults", handler);
        },

        onLoad: function(){
          /* Get a handle to the editor DOM element */
          this.editor = this.$.iframe.contentDocument.querySelector('.kix-appview-editor');
          /* Add a scroll event handler */
          var onScrollHandler = this.onScroll.bind(this);
          this.editor.onscroll =  onScrollHandler;
          /* For page 1 */
          var handler = this.getCurrentPage.bind(this);
          setTimeout(handler, 1000);

          this.$.highlighter.targetElement = this.$.iframe.contentDocument;
        },

        search: function (query) {
          this.$.search_google_images.query = query;
        },

        /*When the user scrolls the document onScroll is triggered. But we are interested in
        an event when the scroll stops. Add a timeout to onScroll, which triggers after 500ms
        If the event triggers, the user has stopped scrolling. */
        onScroll: function(){
          clearTimeout(this.scrollTimer);
          var scrollStopHandler = this.scrollStop.bind(this);
          this.scrollTimer = setTimeout(scrollStopHandler, 500);
        },

        scrollStop: function() {
          var pageno = parseInt((this.editor.scrollTop/1056).toString().split('.')[0]);
          /* Scrolling on the same page */
          if (this.pageno == (pageno+1))
            return;

          this.pageno = pageno+1; //querySelector starts from 1. Hence add 1.

          if (this.sectionIndex[this.pageno]) {
            //Just transition to the already cached content
            this.$.content.selected = this.sectionIndex[this.pageno];
          } else {
            //get the keyworks and images for the new page
            this.getCurrentPage();
          }
        },

        getCurrentPage: function() {
          /* Handle to the current Page */

          var str = '.kix-page:nth-child(' + (this.pageno).toString() + ') > div:nth-child(2) > div:nth-child(1)';
          var content = this.$.iframe.contentDocument.querySelector(str);

          var paragraphs = content.querySelectorAll('.kix-paragraphrenderer');
          var txtObj = {};
          var lineCount = 0;

          for(var i=0;i<paragraphs.length;i++) {
            var lines = paragraphs[i].querySelectorAll('.kix-lineview-content');
            for(var j=0;j<lines.length;j++) {
              txtObj[lineCount]= {'text':lines[j].innerText};
              lineCount++;
            }
          }
          /* Create an object to represent the text structure on this page.
             txtObj is a object with line number as key, and the value is a
             object with 'text' as key & line content with value. The function
             processPageText() is a sample function , demonstrating how you can
             parse the object. NPL should just JSON stringify it and process it.*/
          this.processPageText(txtObj);
          this.addImageCard();
        },

        /* This is test function for demonstration purpose only. */
        /* This function parses the text object and appends them
           in the animated-pages in sections. There is a section for
           each visited page and when the page scrolls we animates the
           transitions to the relevant section */
        processPageText: function(textObject) {
          /* If this is a new page, then reset the extractor and feed the
             whole text , line-by-line to the NLP module */
          if (this.sectionIndex[this.pageno] == null) {
            this.fire('resetextractor', null);
            for (var i=0; i < Object.keys(textObject).length; i++) {
              this.fire('lineadd',
                { pageId: this.pageno, lineId: i, text: textObject[i].text });
            }
          }

          this.fire('getkeywords', { pageId: this.pageno });
        },

        handleSearchResults: function (e) {
          var self = this;

          var images = e.detail;

          for (var i = 0; i < images.length; i++) {
            var img = document.createElement("img");
            img.src = images[i].url;

            // only add images to the display if they load correctly
            img.addEventListener("load", function () {
              self.$.images.appendChild(this);
            });
          }
        },

        getImages: function() {
          this.search(this.$.changed_text.innerText);
        },

        downAction: function() {
          this.$.iframe.style.pointerEvents = 'none';
        },

        upAction: function() {
          this.$.iframe.style.pointerEvents = '';
        },

        /* when the splitter moves, layout the gallery;
           this is to get around the fact that MutationObservers
           don't work when this app runs as a Chrome extension
           (the image-card has a mutation observer on its width
           which automatically calls layout(), but that doesn't
           work here */
        trackAction: function() {
          if (this.pageno && this.imageCards[this.pageno]) {
            this.imageCards[this.pageno].layout();
          }
        },

        closePanel: function() {
          this.$.content_push_panel.style.display = 'none';
          this.open = false;
        },

        togglePanel: function() {
          if (this.open) {
            this.$.content_push_panel.style.display = 'none';
            this.open = false;
          } else {
            this.$.content_push_panel.style.display = 'inline-block';
            this.open = true;
          }
        },

        /**
         * Add an image card (gallery) for the page with ID pageId;
         * if the image card exists for this page already, do nothing.
         *
         * @param String pageId Identifier for the page with which
         * this gallery is associated
         */
        addImageCard: function () {
          if (this.sectionIndex[this.pageno] == null) {
            this.imageCards[this.pageno] = document.createElement('image-card');

            this.imageCards[this.pageno].style.display = 'block';
            this.imageCards[this.pageno].style.height = '100%';
            this.$.content.appendChild(this.imageCards[this.pageno]);
            this.sectionIndex[this.pageno] = this.sectionCount;
            this.sectionCount++;
            this.search(this.pageno,"");
          }

          this.$.content.selected = this.sectionIndex[this.pageno];
        },

        /* perform search for keyphrases and populate the image card
          for the associated page.
          TODO replace this stub with a real implementation */
        search: function (pageId, keyPhrases) {
          // add random images from lorempixel
          var imagesDimensions = [
            {width: 400, height: 300},
            {width: 250, height: 150},
            {width: 150, height: 150},
            {width: 150, height: 150},
            {width: 400, height: 300},
            {width: 600, height: 600},
            {width: 150, height: 150},
            {width: 150, height: 150},
            {width: 400, height: 300},
            {width: 250, height: 150}
          ];

          var dim;
          for (var i = 0; i < imagesDimensions.length; i ++) {
            dim = imagesDimensions[i];
            var src = 'http://lorempixel.com/' +
                      dim.width + '/' + dim.height +
                      '?cacheBust=' + (new Date()).getTime() + i;
            this.imageCards[pageId].appendImage({
              src: src
            });
          }
        }
      }); // Polymer()
    })();

  </script>
</polymer-element>
