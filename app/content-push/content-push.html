<link rel="import" href="../bower_components/core-splitter/core-splitter.html">
<link rel="import" href="../bower_components/core-toolbar/core-toolbar.html">
<link rel="import" href="../bower_components/core-icon-button/core-icon-button.html">
<link rel="import" href="../bower_components/core-icon/core-icon.html">
<link rel="import" href="../bower_components/core-icons/core-icons.html">
<link rel="import" href="../bower_components/core-header-panel/core-header-panel.html">
<link rel="import" href="../bower_components/core-animated-pages/core-animated-pages.html">
<link rel="import" href="../bower_components/core-animated-pages/transitions/slide-from-right.html">
<link rel="import" href="../bower_components/paper-tabs/paper-tabs.html">
<link rel="import" href="./cp-fetcher.html">
<link rel="import" href="./image-results.html">
<link rel='import' href='./keyword-highlighter.html'>

<polymer-element name="content-push" attributes="iframeurl toggle">
  <template>
    <link type="text/css" rel="stylesheet" href="ClearSans/ClearSans.css">
    <link type="text/css" rel="stylesheet" href="styles/content-push.css">
    <div id="container" horizontal layout>
      <iframe id="iframe" flex></iframe>
      <core-splitter id="splitter" direction="right" minSize="220px" on-down="{{downAction}}" on-up="{{upAction}}" on-track="{{trackAction}}"></core-splitter>
      <div id="content_push_panel">
        <!--the panel is made up of a header toolbar, a content toolbar and the content-->
        <core-toolbar id="toolbar">
          <div id="toolbartext" flex>Content Push</div>
          <core-icon-button id="toolbaraction" icon="close" on-tap="{{closePanel}}"></core-icon-button>
        </core-toolbar>

        <!--Tabs Menu-->
        <paper-tabs id="tabs" noink>
          <paper-tab>
            <core-icon icon="drive-image"></core-icon>
          </paper-tab>
          <paper-tab>
            <core-icon icon="drive"></core-icon>
          </paper-tab>
          <paper-tab>
            <core-icon icon="subject"></core-icon>
          </paper-tab>
          <paper-tab>
            <core-icon icon="more-vert"></core-icon>
          </paper-tab>
        </paper-tabs>

        <core-animated-pages id='content' transitions="slide-from-right">
        </core-animated-pages>
      </div><!-- content_push_panel -->
    </div><!-- container -->
    <keyword-highlighter id='highlighter'></keyword-highlighter>
    <cp-fetcher id="fetcher" resultsPerFetch="5"></cp-fetcher>
  </template>

  <script>
    (function contentPushApp() {
      // private properties

      var LINE_CLASS = 'kix-lineview';
      var LINE_CONTENT_SELECTOR = '.kix-lineview-content';
      var SCROLLING_ELEMENT_SELECTOR = '.kix-appview-editor';

      /**
       * Add an image card (gallery) for the page with ID pageId;
       * if the image card exists for this page already, do nothing.
       *
       * @param String pageId Identifier for the page with which
       * this gallery is associated
       */
      var addImageCard = function (self,keywordInfo) {
        if (self.sectionIndex[self.pageno] !== null) {
          self.search(self.pageno, keywordInfo);

          // add handlers for when the image card scroll reaches the
          // bottom or replacement content is requested
          self.imageCards[self.pageno].addEventListener('morecontent', function () {
            self.search(self.pageno, keywordInfo);
          });

          self.imageCards[self.pageno].addEventListener('replacecontent', function () {
            self.search(self.pageno, keywordInfo);
          });

          self.imageCards[self.pageno].addEventListener('mouse-over', function (e) {
            self.$.highlighter.turn(e.detail.groupId, 'on');
          });

          self.imageCards[self.pageno].addEventListener('mouse-out', function (e) {
            self.$.highlighter.turn(e.detail.groupId, 'off');
          });

          self.$.highlighter.prepare(keywordInfo.ranges);
        }

        /*
        refresh the layout in case the panel has changed size since
        the last time the card was displayed
        */
        self.imageCards[self.pageno].layout();

        self.$.content.selected = self.sectionIndex[self.pageno];
      };

      /* find ancestor of node that has className
      for finding the ancestor with .kix-lineview of whatever line has changed */
      var findAncestor = function(node,className) {
        var retVal=null;

        var thisNode=node;
        var cssSelectorNotFound=true;

        while (cssSelectorNotFound && thisNode && thisNode.nodeName!="BODY") {
          cssSelectorNotFound=!thisNode.classList.contains(className);
          if (cssSelectorNotFound) {
            // move into parent node
            thisNode=thisNode.parentNode;
          } else {
            // finished
            retVal=thisNode;
          }
        }

        return retVal;
      };

      // NOTE: doesn't handle removed lines
      var observeDocumentChanges = function(self, callBack) {
        // Create an observer instance
        var observer = new MutationObserver(function(mutations,observerInstance) {
          for (var i = 0; i < mutations.length; i++) {
            var mutation = mutations[i];
            var newNodes = mutation.addedNodes;
            var removedNodes = mutation.removedNodes;

            if (removedNodes !== null) {
              for (var j = 0; j < removedNodes.length; j++) {
                var thisNode = removedNodes[j];
                if (thisNode) {
                  if (typeof thisNode.classList !== 'undefined' &&
                    thisNode.classList.contains(LINE_CLASS)) {
                    console.log('MO:removed line');
                  }
                }
              }
            }

            if (newNodes !== null) {
              for (var j = 0; j < newNodes.length; j++) {
                var thisNode = newNodes[j];
                if (thisNode) {
                  if (thisNode.nodeName === 'SPAN') {
                    if (findAncestor(thisNode, LINE_CLASS) !== null)
                      console.log('MO:editing line');
                  }
                  else if (typeof thisNode.classList !== 'undefined' &&
                    thisNode.classList.contains(LINE_CLASS)) {
                    if (thisNode.getAttribute('cp_line_id') === null) {
                      var lineIdAtt = document.createAttribute('cp_line_id');

                      console.log('MO:new line');

                      lineIdAtt.value = self.numLines;
                      thisNode.setAttributeNode(lineIdAtt);
                      self.numLines++;
                    }
                  }
                }
              }
            }
          }
        });

        // Configuration of the observer:
        var config = {
          attributes: false,
          childList: true,
          subtree: true,
          characterData: false
        };

        // Pass in the target node, as well as the observer options
        observer.observe(self.$.iframe.contentDocument, config);
      };

      Polymer({
        open:true,
        editor:null,
        scrollTimer:0,
        pageno:1, //Current Page numer the user is on
        page:null, //Current page
        numLines: 0,
        sectionIndex:[],
        sectionCount:0,
        /* map from page IDs to image-results elements; each page gets
        its own image-results element (at the moment)*/
        imageCards: {},

        created: function() {
          this.iframeurl="";
        },

        iframeurlChanged: function(oldValue,newValue) {
          //console.log("CP:new iframeurl:",newValue);
          this.$.iframe.src=newValue;
        },

        toggleChanged: function(oldValue,newValue) {
          this.togglePanel();
        },

        createImageResults: function () {
          if (!this.imageCards[this.pageno]) {
            this.imageCards[this.pageno] = document.createElement('image-results');
            this.imageCards[this.pageno].style.display = 'block';
            this.imageCards[this.pageno].style.height = '100%';
            this.$.content.appendChild(this.imageCards[this.pageno]);
            this.sectionIndex[this.pageno] = this.sectionCount;
            this.sectionCount++;
          }
        },

        ready: function() {
          var self=this;
          this.$.iframe.src=this.iframeurl;

          // Add a iframe onLoad handler
          var onLoadHandler = this.onLoad.bind(this);
          this.$.iframe.onload = onLoadHandler;

          this.createImageResults();

          document.addEventListener('keywordlist', function (e) {
            self.createImageResults();
            addImageCard(self,e.detail);
          });
        },

        onLoad: function(){
          /* Get a handle to the editor DOM element */
          this.editor = this.$.iframe.contentDocument.querySelector(
            SCROLLING_ELEMENT_SELECTOR);
          /* Add a scroll event handler */
          var onScrollHandler = this.onScroll.bind(this);
          this.editor.onscroll =  onScrollHandler;
          /* For page 1 */
          var handler = this.getCurrentPage.bind(this);
          setTimeout(handler, 1000);

          this.$.highlighter.targetElement = this.$.iframe.contentDocument;

          observeDocumentChanges(this, function () {});
        },

        /*When the user scrolls the document onScroll is triggered. But we are interested in
        an event when the scroll stops. Add a timeout to onScroll, which triggers after 500ms
        If the event triggers, the user has stopped scrolling. */
        onScroll: function(){
          clearTimeout(this.scrollTimer);
          var scrollStopHandler = this.scrollStop.bind(this);
          this.scrollTimer = setTimeout(scrollStopHandler, 500);
        },

        scrollStop: function() {
          var pageno = parseInt((this.editor.scrollTop/1056).toString().split('.')[0]);
          /* Scrolling on the same page */
          if (this.pageno == (pageno+1))
            return;

          this.pageno = pageno+1; //querySelector starts from 1. Hence add 1.

          if (this.sectionIndex[this.pageno] != null) {
            //Just transition to the already cached content
            this.$.content.selected = this.sectionIndex[this.pageno];
            this.fire('getkeywords', { pageId: this.pageno });
          } else {
            //get the keyworks and images for the new page
            this.getCurrentPage();
          }
        },

        getCurrentPage: function() {
          /* Handle to the current Page */

          var lines = this.$.iframe.contentDocument.querySelectorAll(
            LINE_CONTENT_SELECTOR);

          this.fire('resetextractor', null);

          for (i = this.numLines; i < lines.length; i++) {
            var lineIdAtt = document.createAttribute('cp_line_id');
            lineIdAtt.value = this.numLines;

            lines[i].parentNode.setAttributeNode (lineIdAtt);
            this.fire('lineadd', { pageId: this.pageno, lineId: this.numLines,
                text: lines[i].innerText });

            this.numLines++;
          }

          this.fire('getkeywords', { pageId: this.pageno });
        },

        downAction: function() {
          this.$.iframe.style.pointerEvents = 'none';
        },

        upAction: function() {
          this.$.iframe.style.pointerEvents = '';
        },

        // if the splitter moves, resize the gallery
        trackAction: function () {
          this.imageCards[this.pageno].layout();
        },

        closePanel: function() {
          this.$.content_push_panel.style.display = 'none';
          this.open = false;
        },

        togglePanel: function() {
          if (this.open) {
            this.$.content_push_panel.style.display = 'none';
            this.open = false;
          } else {
            this.$.content_push_panel.style.display = 'inline-block';
            this.open = true;
          }
        },

        /* perform search for keyphrases and populate the image card
          for the associated page. */
        search: function (pageId, keywordInfo) {
          var self = this;

          // search for one keyphrase
          // TODO search for all keyphrases
          var keyphrase = keywordInfo.keywords[0];

          // append each image
          if (keyphrase) {
            this.$.fetcher.fetch(keyphrase.text).then(function (results) {
              for (var i = 0; i < results.length; i++) {
                self.imageCards[pageId].appendImage({
                  src: results[i].src,
                  keyphrase: keyphrase
                });
              }
            });
          }
        }
      }); // Polymer()
    })();

  </script>
</polymer-element>
